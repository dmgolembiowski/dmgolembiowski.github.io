<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>:mod:`unittest.mock` --- mock object library</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7952 2016-07-26 18:15:59Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

.subscript {
  vertical-align: sub;
  font-size: smaller }

.superscript {
  vertical-align: super;
  font-size: smaller }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left, table.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right, table.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

table.align-center {
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

.align-top    {
  vertical-align: top }

.align-middle {
  vertical-align: middle }

.align-bottom {
  vertical-align: bottom }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="mod-unittest-mock-mock-object-library">
<h1 class="title"><a href="#id1"><span class="problematic" id="id2">:mod:`unittest.mock`</span></a> --- mock object library</h1>

<div class="system-message" id="id1">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2); <em><a href="#id2">backlink</a></em></p>
Unknown interpreted text role &quot;mod&quot;.</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 5)</p>
<p>Unknown directive type &quot;module&quot;.</p>
<pre class="literal-block">
.. module:: unittest.mock
   :synopsis: Mock object library.

</pre>
</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 8)</p>
<p>Unknown directive type &quot;moduleauthor&quot;.</p>
<pre class="literal-block">
.. moduleauthor:: Michael Foord &lt;michael&#64;python.org&gt;
</pre>
</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 9)</p>
<p>Unknown directive type &quot;currentmodule&quot;.</p>
<pre class="literal-block">
.. currentmodule:: unittest.mock

</pre>
</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 11)</p>
<p>Unknown directive type &quot;versionadded&quot;.</p>
<pre class="literal-block">
.. versionadded:: 3.3

</pre>
</div>
<p><strong>Source code:</strong> <a href="#id3"><span class="problematic" id="id4">:source:`Lib/unittest/mock.py`</span></a></p>
<div class="system-message" id="id3">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 13); <em><a href="#id4">backlink</a></em></p>
Unknown interpreted text role &quot;source&quot;.</div>
<hr class="docutils" />
<p><a href="#id5"><span class="problematic" id="id6">:mod:`unittest.mock`</span></a> is a library for testing in Python. It allows you to
replace parts of your system under test with mock objects and make assertions
about how they have been used.</p>
<div class="system-message" id="id5">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 17); <em><a href="#id6">backlink</a></em></p>
Unknown interpreted text role &quot;mod&quot;.</div>
<p><a href="#id7"><span class="problematic" id="id8">:mod:`unittest.mock`</span></a> provides a core <a href="#id9"><span class="problematic" id="id10">:class:`Mock`</span></a> class removing the need to
create a host of stubs throughout your test suite. After performing an
action, you can make assertions about which methods / attributes were used
and arguments they were called with. You can also specify return values and
set needed attributes in the normal way.</p>
<div class="system-message" id="id7">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 21); <em><a href="#id8">backlink</a></em></p>
Unknown interpreted text role &quot;mod&quot;.</div>
<div class="system-message" id="id9">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 21); <em><a href="#id10">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<p>Additionally, mock provides a <a href="#id11"><span class="problematic" id="id12">:func:`patch`</span></a> decorator that handles patching
module and class level attributes within the scope of a test, along with
<a href="#id13"><span class="problematic" id="id14">:const:`sentinel`</span></a> for creating unique objects. See the <a class="reference internal" href="#quick-guide">quick guide</a> for
some examples of how to use <a href="#id15"><span class="problematic" id="id16">:class:`Mock`</span></a>, <a href="#id17"><span class="problematic" id="id18">:class:`MagicMock`</span></a> and
<a href="#id19"><span class="problematic" id="id20">:func:`patch`</span></a>.</p>
<div class="system-message" id="id11">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 27); <em><a href="#id12">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id13">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 27); <em><a href="#id14">backlink</a></em></p>
Unknown interpreted text role &quot;const&quot;.</div>
<div class="system-message" id="id15">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 27); <em><a href="#id16">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id17">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 27); <em><a href="#id18">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id19">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 27); <em><a href="#id20">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<p>Mock is designed for use with <a href="#id21"><span class="problematic" id="id22">:mod:`unittest`</span></a> and
is based on the 'action -&gt; assertion' pattern instead of 'record -&gt; replay'
used by many mocking frameworks.</p>
<div class="system-message" id="id21">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 33); <em><a href="#id22">backlink</a></em></p>
Unknown interpreted text role &quot;mod&quot;.</div>
<p>There is a backport of <a href="#id23"><span class="problematic" id="id24">:mod:`unittest.mock`</span></a> for earlier versions of Python,
available as <a class="reference external" href="https://pypi.org/project/mock">mock on PyPI</a>.</p>
<div class="system-message" id="id23">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 37); <em><a href="#id24">backlink</a></em></p>
Unknown interpreted text role &quot;mod&quot;.</div>
<div class="section" id="quick-guide">
<h1>Quick Guide</h1>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 44)</p>
<p>Unknown directive type &quot;testsetup&quot;.</p>
<pre class="literal-block">
.. testsetup::

    class ProductionClass:
        def method(self, a, b, c):
            pass

    class SomeClass:
        &#64;staticmethod
        def static_method(args):
            return args

        &#64;classmethod
        def class_method(cls, args):
            return args


</pre>
</div>
<p><a href="#id25"><span class="problematic" id="id26">:class:`Mock`</span></a> and <a href="#id27"><span class="problematic" id="id28">:class:`MagicMock`</span></a> objects create all attributes and
methods as you access them and store details of how they have been used. You
can configure them, to specify return values or limit what attributes are
available, and then make assertions about how they have been used:</p>
<div class="system-message" id="id25">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 60); <em><a href="#id26">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id27">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 60); <em><a href="#id28">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from unittest.mock import MagicMock
&gt;&gt;&gt; thing = ProductionClass()
&gt;&gt;&gt; thing.method = MagicMock(return_value=3)
&gt;&gt;&gt; thing.method(3, 4, 5, key='value')
3
&gt;&gt;&gt; thing.method.assert_called_with(3, 4, 5, key='value')
</pre>
</blockquote>
<p><a href="#id29"><span class="problematic" id="id30">:attr:`side_effect`</span></a> allows you to perform side effects, including raising an
exception when a mock is called:</p>
<div class="system-message" id="id29">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 72); <em><a href="#id30">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mock = Mock(side_effect=KeyError('foo'))
&gt;&gt;&gt; mock()
Traceback (most recent call last):
 ...
KeyError: 'foo'
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; values = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; def side_effect(arg):
...     return values[arg]
...
&gt;&gt;&gt; mock.side_effect = side_effect
&gt;&gt;&gt; mock('a'), mock('b'), mock('c')
(1, 2, 3)
&gt;&gt;&gt; mock.side_effect = [5, 4, 3, 2, 1]
&gt;&gt;&gt; mock(), mock(), mock()
(5, 4, 3)
</pre>
</blockquote>
<p>Mock has many other ways you can configure it and control its behaviour. For
example the <em>spec</em> argument configures the mock to take its specification
from another object. Attempting to access attributes or methods on the mock
that don't exist on the spec will fail with an <a href="#id31"><span class="problematic" id="id32">:exc:`AttributeError`</span></a>.</p>
<div class="system-message" id="id31">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 92); <em><a href="#id32">backlink</a></em></p>
Unknown interpreted text role &quot;exc&quot;.</div>
<p>The <a href="#id33"><span class="problematic" id="id34">:func:`patch`</span></a> decorator / context manager makes it easy to mock classes or
objects in a module under test. The object you specify will be replaced with a
mock (or other object) during the test and restored when the test ends:</p>
<div class="system-message" id="id33">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 97); <em><a href="#id34">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; from unittest.mock import patch
&gt;&gt;&gt; &#64;patch('module.ClassName2')
... &#64;patch('module.ClassName1')
... def test(MockClass1, MockClass2):
...     module.ClassName1()
...     module.ClassName2()
...     assert MockClass1 is module.ClassName1
...     assert MockClass2 is module.ClassName2
...     assert MockClass1.called
...     assert MockClass2.called
...
&gt;&gt;&gt; test()
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>When you nest patch decorators the mocks are passed in to the decorated
function in the same order they applied (the normal <em>Python</em> order that
decorators are applied). This means from the bottom up, so in the example
above the mock for <tt class="docutils literal">module.ClassName1</tt> is passed in first.</p>
<p>With <a href="#id35"><span class="problematic" id="id36">:func:`patch`</span></a> it matters that you patch objects in the namespace where they
are looked up. This is normally straightforward, but for a quick guide
read <a href="#id37"><span class="problematic" id="id38">:ref:`where to patch &lt;where-to-patch&gt;`</span></a>.</p>
<div class="system-message" id="id35">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 121); <em><a href="#id36">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="last system-message" id="id37">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 121); <em><a href="#id38">backlink</a></em></p>
Unknown interpreted text role &quot;ref&quot;.</div>
</div>
<p>As well as a decorator <a href="#id39"><span class="problematic" id="id40">:func:`patch`</span></a> can be used as a context manager in a with
statement:</p>
<div class="system-message" id="id39">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 125); <em><a href="#id40">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; with patch.object(ProductionClass, 'method', return_value=None) as mock_method:
...     thing = ProductionClass()
...     thing.method(1, 2, 3)
...
&gt;&gt;&gt; mock_method.assert_called_once_with(1, 2, 3)
</pre>
</blockquote>
<p>There is also <a href="#id41"><span class="problematic" id="id42">:func:`patch.dict`</span></a> for setting values in a dictionary just
during a scope and restoring the dictionary to its original state when the test
ends:</p>
<div class="system-message" id="id41">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 135); <em><a href="#id42">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; foo = {'key': 'value'}
&gt;&gt;&gt; original = foo.copy()
&gt;&gt;&gt; with patch.dict(foo, {'newkey': 'newvalue'}, clear=True):
...     assert foo == {'newkey': 'newvalue'}
...
&gt;&gt;&gt; assert foo == original
</pre>
</blockquote>
<p>Mock supports the mocking of Python <a href="#id43"><span class="problematic" id="id44">:ref:`magic methods &lt;magic-methods&gt;`</span></a>. The
easiest way of using magic methods is with the <a href="#id45"><span class="problematic" id="id46">:class:`MagicMock`</span></a> class. It
allows you to do things like:</p>
<div class="system-message" id="id43">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 146); <em><a href="#id44">backlink</a></em></p>
Unknown interpreted text role &quot;ref&quot;.</div>
<div class="system-message" id="id45">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 146); <em><a href="#id46">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mock = MagicMock()
&gt;&gt;&gt; mock.__str__.return_value = 'foobarbaz'
&gt;&gt;&gt; str(mock)
'foobarbaz'
&gt;&gt;&gt; mock.__str__.assert_called_with()
</pre>
</blockquote>
<p>Mock allows you to assign functions (or other Mock instances) to magic methods
and they will be called appropriately. The <a href="#id47"><span class="problematic" id="id48">:class:`MagicMock`</span></a> class is just a Mock
variant that has all of the magic methods pre-created for you (well, all the
useful ones anyway).</p>
<div class="system-message" id="id47">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 156); <em><a href="#id48">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<p>The following is an example of using magic methods with the ordinary Mock
class:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mock = Mock()
&gt;&gt;&gt; mock.__str__ = Mock(return_value='wheeeeee')
&gt;&gt;&gt; str(mock)
'wheeeeee'
</pre>
</blockquote>
<p>For ensuring that the mock objects in your tests have the same api as the
objects they are replacing, you can use <a href="#id49"><span class="problematic" id="id50">:ref:`auto-speccing &lt;auto-speccing&gt;`</span></a>.
Auto-speccing can be done through the <em>autospec</em> argument to patch, or the
<a href="#id51"><span class="problematic" id="id52">:func:`create_autospec`</span></a> function. Auto-speccing creates mock objects that
have the same attributes and methods as the objects they are replacing, and
any functions and methods (including constructors) have the same call
signature as the real object.</p>
<div class="system-message" id="id49">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 169); <em><a href="#id50">backlink</a></em></p>
Unknown interpreted text role &quot;ref&quot;.</div>
<div class="system-message" id="id51">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 169); <em><a href="#id52">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<p>This ensures that your mocks will fail in the same way as your production
code if they are used incorrectly:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from unittest.mock import create_autospec
&gt;&gt;&gt; def function(a, b, c):
...     pass
...
&gt;&gt;&gt; mock_function = create_autospec(function, return_value='fishy')
&gt;&gt;&gt; mock_function(1, 2, 3)
'fishy'
&gt;&gt;&gt; mock_function.assert_called_once_with(1, 2, 3)
&gt;&gt;&gt; mock_function('wrong arguments')
Traceback (most recent call last):
 ...
TypeError: &lt;lambda&gt;() takes exactly 3 arguments (1 given)
</pre>
</blockquote>
<p><a href="#id53"><span class="problematic" id="id54">:func:`create_autospec`</span></a> can also be used on classes, where it copies the signature of
the <tt class="docutils literal">__init__</tt> method, and on callable objects where it copies the signature of
the <tt class="docutils literal">__call__</tt> method.</p>
<div class="system-message" id="id53">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 193); <em><a href="#id54">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
</div>
<div class="section" id="the-mock-class">
<h1>The Mock Class</h1>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 202)</p>
<p>Unknown directive type &quot;testsetup&quot;.</p>
<pre class="literal-block">
.. testsetup::

    import asyncio
    import inspect
    import unittest
    from unittest.mock import sentinel, DEFAULT, ANY
    from unittest.mock import patch, call, Mock, MagicMock, PropertyMock, AsyncMock
    from unittest.mock import mock_open

</pre>
</div>
<p><a href="#id55"><span class="problematic" id="id56">:class:`Mock`</span></a> is a flexible mock object intended to replace the use of stubs and
test doubles throughout your code. Mocks are callable and create attributes as
new mocks when you access them <a class="footnote-reference" href="#id219" id="id57">[1]</a>. Accessing the same attribute will always
return the same mock. Mocks record how you use them, allowing you to make
assertions about what your code has done to them.</p>
<div class="system-message" id="id55">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 211); <em><a href="#id56">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<p><a href="#id58"><span class="problematic" id="id59">:class:`MagicMock`</span></a> is a subclass of <a href="#id60"><span class="problematic" id="id61">:class:`Mock`</span></a> with all the magic methods
pre-created and ready to use. There are also non-callable variants, useful
when you are mocking out objects that aren't callable:
<a href="#id62"><span class="problematic" id="id63">:class:`NonCallableMock`</span></a> and <a href="#id64"><span class="problematic" id="id65">:class:`NonCallableMagicMock`</span></a></p>
<div class="system-message" id="id58">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 217); <em><a href="#id59">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id60">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 217); <em><a href="#id61">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id62">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 217); <em><a href="#id63">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id64">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 217); <em><a href="#id65">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<p>The <a href="#id66"><span class="problematic" id="id67">:func:`patch`</span></a> decorators makes it easy to temporarily replace classes
in a particular module with a <a href="#id68"><span class="problematic" id="id69">:class:`Mock`</span></a> object. By default <a href="#id70"><span class="problematic" id="id71">:func:`patch`</span></a> will create
a <a href="#id72"><span class="problematic" id="id73">:class:`MagicMock`</span></a> for you. You can specify an alternative class of <a href="#id74"><span class="problematic" id="id75">:class:`Mock`</span></a> using
the <em>new_callable</em> argument to <a href="#id76"><span class="problematic" id="id77">:func:`patch`</span></a>.</p>
<div class="system-message" id="id66">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 222); <em><a href="#id67">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id68">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 222); <em><a href="#id69">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id70">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 222); <em><a href="#id71">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id72">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 222); <em><a href="#id73">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id74">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 222); <em><a href="#id75">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id76">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 222); <em><a href="#id77">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<p class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs">Create a new <a href="#id78"><span class="problematic" id="id79">:class:`Mock`</span></a> object. <a href="#id80"><span class="problematic" id="id81">:class:`Mock`</span></a> takes several optional arguments
that specify the behaviour of the Mock object:</p>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id78">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 230); <em><a href="#id79">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id80">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 230); <em><a href="#id81">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<ul class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs">
<li><p class="first"><em>spec</em>: This can be either a list of strings or an existing object (a
class or instance) that acts as the specification for the mock object. If
you pass in an object then a list of strings is formed by calling dir on
the object (excluding unsupported magic attributes and methods).
Accessing any attribute not in this list will raise an <a href="#id82"><span class="problematic" id="id83">:exc:`AttributeError`</span></a>.</p>
<div class="system-message" id="id82">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 233); <em><a href="#id83">backlink</a></em></p>
<p>Unknown interpreted text role &quot;exc&quot;.</p>
</div>
<p>If <em>spec</em> is an object (rather than a list of strings) then
<a href="#id84"><span class="problematic" id="id85">:attr:`~instance.__class__`</span></a> returns the class of the spec object. This
allows mocks to pass <a href="#id86"><span class="problematic" id="id87">:func:`isinstance`</span></a> tests.</p>
<div class="system-message" id="id84">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 239); <em><a href="#id85">backlink</a></em></p>
<p>Unknown interpreted text role &quot;attr&quot;.</p>
</div>
<div class="system-message" id="id86">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 239); <em><a href="#id87">backlink</a></em></p>
<p>Unknown interpreted text role &quot;func&quot;.</p>
</div>
</li>
<li><p class="first"><em>spec_set</em>: A stricter variant of <em>spec</em>. If used, attempting to <em>set</em>
or get an attribute on the mock that isn't on the object passed as
<em>spec_set</em> will raise an <a href="#id88"><span class="problematic" id="id89">:exc:`AttributeError`</span></a>.</p>
<div class="system-message" id="id88">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 243); <em><a href="#id89">backlink</a></em></p>
<p>Unknown interpreted text role &quot;exc&quot;.</p>
</div>
</li>
<li><p class="first"><em>side_effect</em>: A function to be called whenever the Mock is called. See
the <a href="#id90"><span class="problematic" id="id91">:attr:`~Mock.side_effect`</span></a> attribute. Useful for raising exceptions or
dynamically changing return values. The function is called with the same
arguments as the mock, and unless it returns <a href="#id92"><span class="problematic" id="id93">:data:`DEFAULT`</span></a>, the return
value of this function is used as the return value.</p>
<div class="system-message" id="id90">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 247); <em><a href="#id91">backlink</a></em></p>
<p>Unknown interpreted text role &quot;attr&quot;.</p>
</div>
<div class="system-message" id="id92">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 247); <em><a href="#id93">backlink</a></em></p>
<p>Unknown interpreted text role &quot;data&quot;.</p>
</div>
<p>Alternatively <em>side_effect</em> can be an exception class or instance. In
this case the exception will be raised when the mock is called.</p>
<p>If <em>side_effect</em> is an iterable then each call to the mock will return
the next value from the iterable.</p>
<p>A <em>side_effect</em> can be cleared by setting it to <tt class="docutils literal">None</tt>.</p>
</li>
<li><p class="first"><em>return_value</em>: The value returned when the mock is called. By default
this is a new Mock (created on first access). See the
<a href="#id94"><span class="problematic" id="id95">:attr:`return_value`</span></a> attribute.</p>
<div class="system-message" id="id94">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 261); <em><a href="#id95">backlink</a></em></p>
<p>Unknown interpreted text role &quot;attr&quot;.</p>
</div>
</li>
<li><p class="first"><em>unsafe</em>: By default if any attribute starts with <em>assert</em> or
<em>assret</em> will raise an <a href="#id96"><span class="problematic" id="id97">:exc:`AttributeError`</span></a>. Passing <tt class="docutils literal">unsafe=True</tt>
will allow access to these attributes.</p>
<div class="system-message" id="id96">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 265); <em><a href="#id97">backlink</a></em></p>
<p>Unknown interpreted text role &quot;exc&quot;.</p>
</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 269)</p>
<p>Unknown directive type &quot;versionadded&quot;.</p>
<pre class="literal-block">
.. versionadded:: 3.5

</pre>
</div>
</li>
<li><p class="first"><em>wraps</em>: Item for the mock object to wrap. If <em>wraps</em> is not <tt class="docutils literal">None</tt> then
calling the Mock will pass the call through to the wrapped object
(returning the real result). Attribute access on the mock will return a
Mock object that wraps the corresponding attribute of the wrapped
object (so attempting to access an attribute that doesn't exist will
raise an <a href="#id98"><span class="problematic" id="id99">:exc:`AttributeError`</span></a>).</p>
<div class="system-message" id="id98">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 271); <em><a href="#id99">backlink</a></em></p>
<p>Unknown interpreted text role &quot;exc&quot;.</p>
</div>
<p>If the mock has an explicit <em>return_value</em> set then calls are not passed
to the wrapped object and the <em>return_value</em> is returned instead.</p>
</li>
<li><p class="first"><em>name</em>: If the mock has a name then it will be used in the repr of the
mock. This can be useful for debugging. The name is propagated to child
mocks.</p>
</li>
</ul>
<p class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs">Mocks can also be called with arbitrary keyword arguments. These will be
used to set attributes on the mock after it is created. See the
<a href="#id100"><span class="problematic" id="id101">:meth:`configure_mock`</span></a> method for details.</p>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id100">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 285); <em><a href="#id101">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 289)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: assert_called()

    Assert that the mock was called at least once.

        &gt;&gt;&gt; mock = Mock()
        &gt;&gt;&gt; mock.method()
        &lt;Mock name='mock.method()' id='...'&gt;
        &gt;&gt;&gt; mock.method.assert_called()

    .. versionadded:: 3.6

</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 300)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: assert_called_once()

    Assert that the mock was called exactly once.

        &gt;&gt;&gt; mock = Mock()
        &gt;&gt;&gt; mock.method()
        &lt;Mock name='mock.method()' id='...'&gt;
        &gt;&gt;&gt; mock.method.assert_called_once()
        &gt;&gt;&gt; mock.method()
        &lt;Mock name='mock.method()' id='...'&gt;
        &gt;&gt;&gt; mock.method.assert_called_once()
        Traceback (most recent call last):
        ...
        AssertionError: Expected 'method' to have been called once. Called 2 times.

    .. versionadded:: 3.6


</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 318)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: assert_called_with(*args, **kwargs)

    This method is a convenient way of asserting that the last call has been
    made in a particular way:

        &gt;&gt;&gt; mock = Mock()
        &gt;&gt;&gt; mock.method(1, 2, 3, test='wow')
        &lt;Mock name='mock.method()' id='...'&gt;
        &gt;&gt;&gt; mock.method.assert_called_with(1, 2, 3, test='wow')

</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 328)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: assert_called_once_with(*args, **kwargs)

   Assert that the mock was called exactly once and that that call was
   with the specified arguments.

        &gt;&gt;&gt; mock = Mock(return_value=None)
        &gt;&gt;&gt; mock('foo', bar='baz')
        &gt;&gt;&gt; mock.assert_called_once_with('foo', bar='baz')
        &gt;&gt;&gt; mock('other', bar='values')
        &gt;&gt;&gt; mock.assert_called_once_with('other', bar='values')
        Traceback (most recent call last):
          ...
        AssertionError: Expected 'mock' to be called once. Called 2 times.


</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 343)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: assert_any_call(*args, **kwargs)

    assert the mock has been called with the specified arguments.

    The assert passes if the mock has *ever* been called, unlike
    :meth:`assert_called_with` and :meth:`assert_called_once_with` that
    only pass if the call is the most recent one, and in the case of
    :meth:`assert_called_once_with` it must also be the only call.

        &gt;&gt;&gt; mock = Mock(return_value=None)
        &gt;&gt;&gt; mock(1, 2, arg='thing')
        &gt;&gt;&gt; mock('some', 'thing', 'else')
        &gt;&gt;&gt; mock.assert_any_call(1, 2, arg='thing')


</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 358)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: assert_has_calls(calls, any_order=False)

    assert the mock has been called with the specified calls.
    The :attr:`mock_calls` list is checked for the calls.

    If *any_order* is false then the calls must be
    sequential. There can be extra calls before or after the
    specified calls.

    If *any_order* is true then the calls can be in any order, but
    they must all appear in :attr:`mock_calls`.

        &gt;&gt;&gt; mock = Mock(return_value=None)
        &gt;&gt;&gt; mock(1)
        &gt;&gt;&gt; mock(2)
        &gt;&gt;&gt; mock(3)
        &gt;&gt;&gt; mock(4)
        &gt;&gt;&gt; calls = [call(2), call(3)]
        &gt;&gt;&gt; mock.assert_has_calls(calls)
        &gt;&gt;&gt; calls = [call(4), call(2), call(3)]
        &gt;&gt;&gt; mock.assert_has_calls(calls, any_order=True)

</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 380)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: assert_not_called()

    Assert the mock was never called.

        &gt;&gt;&gt; m = Mock()
        &gt;&gt;&gt; m.hello.assert_not_called()
        &gt;&gt;&gt; obj = m.hello()
        &gt;&gt;&gt; m.hello.assert_not_called()
        Traceback (most recent call last):
          ...
        AssertionError: Expected 'hello' to not have been called. Called 1 times.

    .. versionadded:: 3.5


</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 395)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: reset_mock(*, return_value=False, side_effect=False)

    The reset_mock method resets all the call attributes on a mock object:

        &gt;&gt;&gt; mock = Mock(return_value=None)
        &gt;&gt;&gt; mock('hello')
        &gt;&gt;&gt; mock.called
        True
        &gt;&gt;&gt; mock.reset_mock()
        &gt;&gt;&gt; mock.called
        False

    .. versionchanged:: 3.6
       Added two keyword only argument to the reset_mock function.

    This can be useful where you want to make a series of assertions that
    reuse the same object. Note that :meth:`reset_mock` *doesn't* clear the
    return value, :attr:`side_effect` or any child attributes you have
    set using normal assignment by default. In case you want to reset
    *return_value* or :attr:`side_effect`, then pass the corresponding
    parameter as ``True``. Child mocks and the return value mock
    (if any) are reset as well.

    .. note:: *return_value*, and :attr:`side_effect` are keyword only
              argument.


</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 422)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: mock_add_spec(spec, spec_set=False)

    Add a spec to a mock. *spec* can either be an object or a
    list of strings. Only attributes on the *spec* can be fetched as
    attributes from the mock.

    If *spec_set* is true then only attributes on the spec can be set.


</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 431)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: attach_mock(mock, attribute)

    Attach a mock as an attribute of this one, replacing its name and
    parent. Calls to the attached mock will be recorded in the
    :attr:`method_calls` and :attr:`mock_calls` attributes of this one.


</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 438)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: configure_mock(**kwargs)

    Set attributes on the mock through keyword arguments.

    Attributes plus return values and side effects can be set on child
    mocks using standard dot notation and unpacking a dictionary in the
    method call:

        &gt;&gt;&gt; mock = Mock()
        &gt;&gt;&gt; attrs = {'method.return_value': 3, 'other.side_effect': KeyError}
        &gt;&gt;&gt; mock.configure_mock(**attrs)
        &gt;&gt;&gt; mock.method()
        3
        &gt;&gt;&gt; mock.other()
        Traceback (most recent call last):
          ...
        KeyError

    The same thing can be achieved in the constructor call to mocks:

        &gt;&gt;&gt; attrs = {'method.return_value': 3, 'other.side_effect': KeyError}
        &gt;&gt;&gt; mock = Mock(some_attribute='eggs', **attrs)
        &gt;&gt;&gt; mock.some_attribute
        'eggs'
        &gt;&gt;&gt; mock.method()
        3
        &gt;&gt;&gt; mock.other()
        Traceback (most recent call last):
          ...
        KeyError

    :meth:`configure_mock` exists to make it easier to do configuration
    after the mock has been created.


</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 473)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: __dir__()

    :class:`Mock` objects limit the results of ``dir(some_mock)`` to useful results.
    For mocks with a *spec* this includes all the permitted attributes
    for the mock.

    See :data:`FILTER_DIR` for what this filtering does, and how to
    switch it off.


</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 483)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: _get_child_mock(**kw)

    Create the child mocks for attributes and return value.
    By default child mocks will be the same type as the parent.
    Subclasses of Mock may want to override this to customize the way
    child mocks are made.

    For non-callable mocks the callable variant will be used (rather than
    any custom subclass).


</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 494)</p>
<p>Unknown directive type &quot;attribute&quot;.</p>
<pre class="literal-block">
.. attribute:: called

    A boolean representing whether or not the mock object has been called:

        &gt;&gt;&gt; mock = Mock(return_value=None)
        &gt;&gt;&gt; mock.called
        False
        &gt;&gt;&gt; mock()
        &gt;&gt;&gt; mock.called
        True

</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 505)</p>
<p>Unknown directive type &quot;attribute&quot;.</p>
<pre class="literal-block">
.. attribute:: call_count

    An integer telling you how many times the mock object has been called:

        &gt;&gt;&gt; mock = Mock(return_value=None)
        &gt;&gt;&gt; mock.call_count
        0
        &gt;&gt;&gt; mock()
        &gt;&gt;&gt; mock()
        &gt;&gt;&gt; mock.call_count
        2

</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 517)</p>
<p>Unknown directive type &quot;attribute&quot;.</p>
<pre class="literal-block">
.. attribute:: return_value

    Set this to configure the value returned by calling the mock:

        &gt;&gt;&gt; mock = Mock()
        &gt;&gt;&gt; mock.return_value = 'fish'
        &gt;&gt;&gt; mock()
        'fish'

    The default return value is a mock object and you can configure it in
    the normal way:

        &gt;&gt;&gt; mock = Mock()
        &gt;&gt;&gt; mock.return_value.attribute = sentinel.Attribute
        &gt;&gt;&gt; mock.return_value()
        &lt;Mock name='mock()()' id='...'&gt;
        &gt;&gt;&gt; mock.return_value.assert_called_with()

    :attr:`return_value` can also be set in the constructor:

        &gt;&gt;&gt; mock = Mock(return_value=3)
        &gt;&gt;&gt; mock.return_value
        3
        &gt;&gt;&gt; mock()
        3


</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 544)</p>
<p>Unknown directive type &quot;attribute&quot;.</p>
<pre class="literal-block">
.. attribute:: side_effect

    This can either be a function to be called when the mock is called,
    an iterable or an exception (class or instance) to be raised.

    If you pass in a function it will be called with same arguments as the
    mock and unless the function returns the :data:`DEFAULT` singleton the
    call to the mock will then return whatever the function returns. If the
    function returns :data:`DEFAULT` then the mock will return its normal
    value (from the :attr:`return_value`).

    If you pass in an iterable, it is used to retrieve an iterator which
    must yield a value on every call.  This value can either be an exception
    instance to be raised, or a value to be returned from the call to the
    mock (:data:`DEFAULT` handling is identical to the function case).

    An example of a mock that raises an exception (to test exception
    handling of an API):

        &gt;&gt;&gt; mock = Mock()
        &gt;&gt;&gt; mock.side_effect = Exception('Boom!')
        &gt;&gt;&gt; mock()
        Traceback (most recent call last):
          ...
        Exception: Boom!

    Using :attr:`side_effect` to return a sequence of values:

        &gt;&gt;&gt; mock = Mock()
        &gt;&gt;&gt; mock.side_effect = [3, 2, 1]
        &gt;&gt;&gt; mock(), mock(), mock()
        (3, 2, 1)

    Using a callable:

        &gt;&gt;&gt; mock = Mock(return_value=3)
        &gt;&gt;&gt; def side_effect(*args, **kwargs):
        ...     return DEFAULT
        ...
        &gt;&gt;&gt; mock.side_effect = side_effect
        &gt;&gt;&gt; mock()
        3

    :attr:`side_effect` can be set in the constructor. Here's an example that
    adds one to the value the mock is called with and returns it:

        &gt;&gt;&gt; side_effect = lambda value: value + 1
        &gt;&gt;&gt; mock = Mock(side_effect=side_effect)
        &gt;&gt;&gt; mock(3)
        4
        &gt;&gt;&gt; mock(-8)
        -7

    Setting :attr:`side_effect` to ``None`` clears it:

        &gt;&gt;&gt; m = Mock(side_effect=KeyError, return_value=3)
        &gt;&gt;&gt; m()
        Traceback (most recent call last):
         ...
        KeyError
        &gt;&gt;&gt; m.side_effect = None
        &gt;&gt;&gt; m()
        3


</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 609)</p>
<p>Unknown directive type &quot;attribute&quot;.</p>
<pre class="literal-block">
.. attribute:: call_args

    This is either ``None`` (if the mock hasn't been called), or the
    arguments that the mock was last called with. This will be in the
    form of a tuple: the first member, which can also be accessed through
    the ``args`` property, is any ordered arguments the mock was
    called with (or an empty tuple) and the second member, which can
    also be accessed through the ``kwargs`` property, is any keyword
    arguments (or an empty dictionary).

        &gt;&gt;&gt; mock = Mock(return_value=None)
        &gt;&gt;&gt; print(mock.call_args)
        None
        &gt;&gt;&gt; mock()
        &gt;&gt;&gt; mock.call_args
        call()
        &gt;&gt;&gt; mock.call_args == ()
        True
        &gt;&gt;&gt; mock(3, 4)
        &gt;&gt;&gt; mock.call_args
        call(3, 4)
        &gt;&gt;&gt; mock.call_args == ((3, 4),)
        True
        &gt;&gt;&gt; mock.call_args.args
        (3, 4)
        &gt;&gt;&gt; mock.call_args.kwargs
        {}
        &gt;&gt;&gt; mock(3, 4, 5, key='fish', next='w00t!')
        &gt;&gt;&gt; mock.call_args
        call(3, 4, 5, key='fish', next='w00t!')
        &gt;&gt;&gt; mock.call_args.args
        (3, 4, 5)
        &gt;&gt;&gt; mock.call_args.kwargs
        {'key': 'fish', 'next': 'w00t!'}

    :attr:`call_args`, along with members of the lists :attr:`call_args_list`,
    :attr:`method_calls` and :attr:`mock_calls` are :data:`call` objects.
    These are tuples, so they can be unpacked to get at the individual
    arguments and make more complex assertions. See
    :ref:`calls as tuples &lt;calls-as-tuples&gt;`.

    .. versionchanged:: 3.8
       Added ``args`` and ``kwargs`` properties.


</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 654)</p>
<p>Unknown directive type &quot;attribute&quot;.</p>
<pre class="literal-block">
.. attribute:: call_args_list

    This is a list of all the calls made to the mock object in sequence
    (so the length of the list is the number of times it has been
    called). Before any calls have been made it is an empty list. The
    :data:`call` object can be used for conveniently constructing lists of
    calls to compare with :attr:`call_args_list`.

        &gt;&gt;&gt; mock = Mock(return_value=None)
        &gt;&gt;&gt; mock()
        &gt;&gt;&gt; mock(3, 4)
        &gt;&gt;&gt; mock(key='fish', next='w00t!')
        &gt;&gt;&gt; mock.call_args_list
        [call(), call(3, 4), call(key='fish', next='w00t!')]
        &gt;&gt;&gt; expected = [(), ((3, 4),), ({'key': 'fish', 'next': 'w00t!'},)]
        &gt;&gt;&gt; mock.call_args_list == expected
        True

    Members of :attr:`call_args_list` are :data:`call` objects. These can be
    unpacked as tuples to get at the individual arguments. See
    :ref:`calls as tuples &lt;calls-as-tuples&gt;`.


</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 677)</p>
<p>Unknown directive type &quot;attribute&quot;.</p>
<pre class="literal-block">
.. attribute:: method_calls

    As well as tracking calls to themselves, mocks also track calls to
    methods and attributes, and *their* methods and attributes:

        &gt;&gt;&gt; mock = Mock()
        &gt;&gt;&gt; mock.method()
        &lt;Mock name='mock.method()' id='...'&gt;
        &gt;&gt;&gt; mock.property.method.attribute()
        &lt;Mock name='mock.property.method.attribute()' id='...'&gt;
        &gt;&gt;&gt; mock.method_calls
        [call.method(), call.property.method.attribute()]

    Members of :attr:`method_calls` are :data:`call` objects. These can be
    unpacked as tuples to get at the individual arguments. See
    :ref:`calls as tuples &lt;calls-as-tuples&gt;`.


</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 695)</p>
<p>Unknown directive type &quot;attribute&quot;.</p>
<pre class="literal-block">
.. attribute:: mock_calls

    :attr:`mock_calls` records *all* calls to the mock object, its methods,
    magic methods *and* return value mocks.

        &gt;&gt;&gt; mock = MagicMock()
        &gt;&gt;&gt; result = mock(1, 2, 3)
        &gt;&gt;&gt; mock.first(a=3)
        &lt;MagicMock name='mock.first()' id='...'&gt;
        &gt;&gt;&gt; mock.second()
        &lt;MagicMock name='mock.second()' id='...'&gt;
        &gt;&gt;&gt; int(mock)
        1
        &gt;&gt;&gt; result(1)
        &lt;MagicMock name='mock()()' id='...'&gt;
        &gt;&gt;&gt; expected = [call(1, 2, 3), call.first(a=3), call.second(),
        ... call.__int__(), call()(1)]
        &gt;&gt;&gt; mock.mock_calls == expected
        True

    Members of :attr:`mock_calls` are :data:`call` objects. These can be
    unpacked as tuples to get at the individual arguments. See
    :ref:`calls as tuples &lt;calls-as-tuples&gt;`.

    .. note::

        The way :attr:`mock_calls` are recorded means that where nested
        calls are made, the parameters of ancestor calls are not recorded
        and so will always compare equal:

            &gt;&gt;&gt; mock = MagicMock()
            &gt;&gt;&gt; mock.top(a=3).bottom()
            &lt;MagicMock name='mock.top().bottom()' id='...'&gt;
            &gt;&gt;&gt; mock.mock_calls
            [call.top(a=3), call.top().bottom()]
            &gt;&gt;&gt; mock.mock_calls[-1] == call.top(a=-1).bottom()
            True

</pre>
</div>
<div class="mock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 733)</p>
<p>Unknown directive type &quot;attribute&quot;.</p>
<pre class="literal-block">
.. attribute:: __class__

    Normally the :attr:`__class__` attribute of an object will return its type.
    For a mock object with a :attr:`spec`, ``__class__`` returns the spec class
    instead. This allows mock objects to pass :func:`isinstance` tests for the
    object they are replacing / masquerading as:

        &gt;&gt;&gt; mock = Mock(spec=3)
        &gt;&gt;&gt; isinstance(mock, int)
        True

    :attr:`__class__` is assignable to, this allows a mock to pass an
    :func:`isinstance` check without forcing you to use a spec:

        &gt;&gt;&gt; mock = Mock()
        &gt;&gt;&gt; mock.__class__ = dict
        &gt;&gt;&gt; isinstance(mock, dict)
        True
</pre>
</div>
<p class="noncallablemock-spec-none wraps-none name-none spec-set-none kwargs">A non-callable version of <a href="#id102"><span class="problematic" id="id103">:class:`Mock`</span></a>. The constructor parameters have the same
meaning of <a href="#id104"><span class="problematic" id="id105">:class:`Mock`</span></a>, with the exception of <em>return_value</em> and <em>side_effect</em>
which have no meaning on a non-callable mock.</p>
<div class="noncallablemock-spec-none wraps-none name-none spec-set-none kwargs system-message" id="id102">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 754); <em><a href="#id103">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="noncallablemock-spec-none wraps-none name-none spec-set-none kwargs system-message" id="id104">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 754); <em><a href="#id105">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<p>Mock objects that use a class or an instance as a <a href="#id106"><span class="problematic" id="id107">:attr:`spec`</span></a> or
<a href="#id108"><span class="problematic" id="id109">:attr:`spec_set`</span></a> are able to pass <a href="#id110"><span class="problematic" id="id111">:func:`isinstance`</span></a> tests:</p>
<div class="system-message" id="id106">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 758); <em><a href="#id107">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id108">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 758); <em><a href="#id109">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id110">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 758); <em><a href="#id111">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mock = Mock(spec=SomeClass)
&gt;&gt;&gt; isinstance(mock, SomeClass)
True
&gt;&gt;&gt; mock = Mock(spec_set=SomeClass())
&gt;&gt;&gt; isinstance(mock, SomeClass)
True
</pre>
</blockquote>
<p>The <a href="#id112"><span class="problematic" id="id113">:class:`Mock`</span></a> classes have support for mocking magic methods. See <a href="#id114"><span class="problematic" id="id115">:ref:`magic
methods &lt;magic-methods&gt;`</span></a> for the full details.</p>
<div class="system-message" id="id112">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 768); <em><a href="#id113">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id114">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 768); <em><a href="#id115">backlink</a></em></p>
Unknown interpreted text role &quot;ref&quot;.</div>
<p>The mock classes and the <a href="#id116"><span class="problematic" id="id117">:func:`patch`</span></a> decorators all take arbitrary keyword
arguments for configuration. For the <a href="#id118"><span class="problematic" id="id119">:func:`patch`</span></a> decorators the keywords are
passed to the constructor of the mock being created. The keyword arguments
are for configuring attributes of the mock:</p>
<div class="system-message" id="id116">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 771); <em><a href="#id117">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id118">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 771); <em><a href="#id119">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; m = MagicMock(attribute=3, other='fish')
&gt;&gt;&gt; m.attribute
3
&gt;&gt;&gt; m.other
'fish'
</pre>
</blockquote>
<p>The return value and side effect of child mocks can be set in the same way,
using dotted notation. As you can't use dotted names directly in a call you
have to create a dictionary and unpack it using <tt class="docutils literal">**</tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; attrs = {'method.return_value': 3, 'other.side_effect': KeyError}
&gt;&gt;&gt; mock = Mock(some_attribute='eggs', **attrs)
&gt;&gt;&gt; mock.some_attribute
'eggs'
&gt;&gt;&gt; mock.method()
3
&gt;&gt;&gt; mock.other()
Traceback (most recent call last):
  ...
KeyError
</pre>
</blockquote>
<p>A callable mock which was created with a <em>spec</em> (or a <em>spec_set</em>) will
introspect the specification object's signature when matching calls to
the mock.  Therefore, it can match the actual call's arguments regardless
of whether they were passed positionally or by name:</p>
<pre class="literal-block">
&gt;&gt;&gt; def f(a, b, c): pass
...
&gt;&gt;&gt; mock = Mock(spec=f)
&gt;&gt;&gt; mock(1, 2, c=3)
&lt;Mock name='mock()' id='140161580456576'&gt;
&gt;&gt;&gt; mock.assert_called_with(1, 2, 3)
&gt;&gt;&gt; mock.assert_called_with(a=1, b=2, c=3)
</pre>
<p>This applies to <a href="#id120"><span class="problematic" id="id121">:meth:`~Mock.assert_called_with`</span></a>,
<a href="#id122"><span class="problematic" id="id123">:meth:`~Mock.assert_called_once_with`</span></a>, <a href="#id124"><span class="problematic" id="id125">:meth:`~Mock.assert_has_calls`</span></a> and
<a href="#id126"><span class="problematic" id="id127">:meth:`~Mock.assert_any_call`</span></a>.  When <a href="#id128"><span class="problematic" id="id129">:ref:`auto-speccing`</span></a>, it will also
apply to method calls on the mock object.</p>
<div class="system-message" id="id120">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 810); <em><a href="#id121">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id122">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 810); <em><a href="#id123">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id124">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 810); <em><a href="#id125">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id126">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 810); <em><a href="#id127">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id128">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 810); <em><a href="#id129">backlink</a></em></p>
Unknown interpreted text role &quot;ref&quot;.</div>
<blockquote>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 815)</p>
<p>Unknown directive type &quot;versionchanged&quot;.</p>
<pre class="literal-block">
.. versionchanged:: 3.4
   Added signature introspection on specced and autospecced mock objects.


</pre>
</div>
</blockquote>
<p class="propertymock-args kwargs">A mock intended to be used as a property, or other descriptor, on a class.
<a href="#id130"><span class="problematic" id="id131">:class:`PropertyMock`</span></a> provides <a href="#id132"><span class="problematic" id="id133">:meth:`__get__`</span></a> and <a href="#id134"><span class="problematic" id="id135">:meth:`__set__`</span></a> methods
so you can specify a return value when it is fetched.</p>
<div class="propertymock-args kwargs system-message" id="id130">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 821); <em><a href="#id131">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="propertymock-args kwargs system-message" id="id132">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 821); <em><a href="#id133">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="propertymock-args kwargs system-message" id="id134">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 821); <em><a href="#id135">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<p class="propertymock-args kwargs">Fetching a <a href="#id136"><span class="problematic" id="id137">:class:`PropertyMock`</span></a> instance from an object calls the mock, with
no args. Setting it calls the mock with the value being set.</p>
<div class="propertymock-args kwargs system-message" id="id136">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 825); <em><a href="#id137">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<pre class="propertymock-args kwargs literal-block">
&gt;&gt;&gt; class Foo:
...     &#64;property
...     def foo(self):
...         return 'something'
...     &#64;foo.setter
...     def foo(self, value):
...         pass
...
&gt;&gt;&gt; with patch('__main__.Foo.foo', new_callable=PropertyMock) as mock_foo:
...     mock_foo.return_value = 'mockity-mock'
...     this_foo = Foo()
...     print(this_foo.foo)
...     this_foo.foo = 6
...
mockity-mock
&gt;&gt;&gt; mock_foo.mock_calls
[call(), call(6)]
</pre>
<p>Because of the way mock attributes are stored you can't directly attach a
<a href="#id138"><span class="problematic" id="id139">:class:`PropertyMock`</span></a> to a mock object. Instead you can attach it to the mock type
object:</p>
<div class="system-message" id="id138">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 846); <em><a href="#id139">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; m = MagicMock()
&gt;&gt;&gt; p = PropertyMock(return_value=3)
&gt;&gt;&gt; type(m).foo = p
&gt;&gt;&gt; m.foo
3
&gt;&gt;&gt; p.assert_called_once_with()
</pre>
<p class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs">An asynchronous version of <a href="#id140"><span class="problematic" id="id141">:class:`MagicMock`</span></a>. The <a href="#id142"><span class="problematic" id="id143">:class:`AsyncMock`</span></a> object will
behave so the object is recognized as an async function, and the result of a
call is an awaitable.</p>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id140">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 860); <em><a href="#id141">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id142">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 860); <em><a href="#id143">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<blockquote class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs">
<pre class="doctest-block">
&gt;&gt;&gt; mock = AsyncMock()
&gt;&gt;&gt; asyncio.iscoroutinefunction(mock)
True
&gt;&gt;&gt; inspect.isawaitable(mock())  # doctest: +SKIP
True
</pre>
</blockquote>
<p class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs">The result of <tt class="docutils literal">mock()</tt> is an async function which will have the outcome
of <tt class="docutils literal">side_effect</tt> or <tt class="docutils literal">return_value</tt> after it has been awaited:</p>
<ul class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs">
<li><p class="first">if <tt class="docutils literal">side_effect</tt> is a function, the async function will return the
result of that function,</p>
</li>
<li><p class="first">if <tt class="docutils literal">side_effect</tt> is an exception, the async function will raise the
exception,</p>
</li>
<li><p class="first">if <tt class="docutils literal">side_effect</tt> is an iterable, the async function will return the
next value of the iterable, however, if the sequence of result is
exhausted, <tt class="docutils literal">StopAsyncIteration</tt> is raised immediately,</p>
</li>
<li><p class="first">if <tt class="docutils literal">side_effect</tt> is not defined, the async function will return the
value defined by <tt class="docutils literal">return_value</tt>, hence, by default, the async function
returns a new <a href="#id144"><span class="problematic" id="id145">:class:`AsyncMock`</span></a> object.</p>
<div class="system-message" id="id144">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 880); <em><a href="#id145">backlink</a></em></p>
<p>Unknown interpreted text role &quot;class&quot;.</p>
</div>
</li>
</ul>
<p class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs">Setting the <em>spec</em> of a <a href="#id146"><span class="problematic" id="id147">:class:`Mock`</span></a> or <a href="#id148"><span class="problematic" id="id149">:class:`MagicMock`</span></a> to an async function
will result in a coroutine object being returned after calling.</p>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id146">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 885); <em><a href="#id147">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id148">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 885); <em><a href="#id149">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<blockquote class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs">
<pre class="doctest-block">
&gt;&gt;&gt; async def async_func(): pass
...
&gt;&gt;&gt; mock = MagicMock(async_func)
&gt;&gt;&gt; mock
&lt;MagicMock spec='function' id='...'&gt;
&gt;&gt;&gt; mock()  # doctest: +SKIP
&lt;coroutine object AsyncMockMixin._mock_call at ...&gt;
</pre>
</blockquote>
<p class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs">Setting the <em>spec</em> of a <a href="#id150"><span class="problematic" id="id151">:class:`Mock`</span></a>, <a href="#id152"><span class="problematic" id="id153">:class:`MagicMock`</span></a>, or <a href="#id154"><span class="problematic" id="id155">:class:`AsyncMock`</span></a>
to a class with asynchronous and synchronous functions will automatically
detect the synchronous functions and set them as <a href="#id156"><span class="problematic" id="id157">:class:`MagicMock`</span></a> (if the
parent mock is <a href="#id158"><span class="problematic" id="id159">:class:`AsyncMock`</span></a> or <a href="#id160"><span class="problematic" id="id161">:class:`MagicMock`</span></a>) or <a href="#id162"><span class="problematic" id="id163">:class:`Mock`</span></a> (if
the parent mock is <a href="#id164"><span class="problematic" id="id165">:class:`Mock`</span></a>). All asynchronous functions will be
<a href="#id166"><span class="problematic" id="id167">:class:`AsyncMock`</span></a>.</p>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id150">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 897); <em><a href="#id151">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id152">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 897); <em><a href="#id153">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id154">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 897); <em><a href="#id155">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id156">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 897); <em><a href="#id157">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id158">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 897); <em><a href="#id159">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id160">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 897); <em><a href="#id161">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id162">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 897); <em><a href="#id163">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id164">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 897); <em><a href="#id165">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message" id="id166">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 897); <em><a href="#id167">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<pre class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs doctest-block">
&gt;&gt;&gt; class ExampleClass:
...     def sync_foo():
...         pass
...     async def async_foo():
...         pass
...
&gt;&gt;&gt; a_mock = AsyncMock(ExampleClass)
&gt;&gt;&gt; a_mock.sync_foo
&lt;MagicMock name='mock.sync_foo' id='...'&gt;
&gt;&gt;&gt; a_mock.async_foo
&lt;AsyncMock name='mock.async_foo' id='...'&gt;
&gt;&gt;&gt; mock = Mock(ExampleClass)
&gt;&gt;&gt; mock.sync_foo
&lt;Mock name='mock.sync_foo' id='...'&gt;
&gt;&gt;&gt; mock.async_foo
&lt;AsyncMock name='mock.async_foo' id='...'&gt;
</pre>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 921)</p>
<p>Unknown directive type &quot;versionadded&quot;.</p>
<pre class="literal-block">
.. versionadded:: 3.8

</pre>
</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 923)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: assert_awaited()

    Assert that the mock was awaited at least once. Note that this is separate
    from the object having been called, the ``await`` keyword must be used:

        &gt;&gt;&gt; mock = AsyncMock()
        &gt;&gt;&gt; async def main(coroutine_mock):
        ...     await coroutine_mock
        ...
        &gt;&gt;&gt; coroutine_mock = mock()
        &gt;&gt;&gt; mock.called
        True
        &gt;&gt;&gt; mock.assert_awaited()
        Traceback (most recent call last):
        ...
        AssertionError: Expected mock to have been awaited.
        &gt;&gt;&gt; asyncio.run(main(coroutine_mock))
        &gt;&gt;&gt; mock.assert_awaited()

</pre>
</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 942)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: assert_awaited_once()

    Assert that the mock was awaited exactly once.

      &gt;&gt;&gt; mock = AsyncMock()
      &gt;&gt;&gt; async def main():
      ...     await mock()
      ...
      &gt;&gt;&gt; asyncio.run(main())
      &gt;&gt;&gt; mock.assert_awaited_once()
      &gt;&gt;&gt; asyncio.run(main())
      &gt;&gt;&gt; mock.method.assert_awaited_once()
      Traceback (most recent call last):
      ...
      AssertionError: Expected mock to have been awaited once. Awaited 2 times.

</pre>
</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 958)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: assert_awaited_with(*args, **kwargs)

    Assert that the last await was with the specified arguments.

      &gt;&gt;&gt; mock = AsyncMock()
      &gt;&gt;&gt; async def main(*args, **kwargs):
      ...     await mock(*args, **kwargs)
      ...
      &gt;&gt;&gt; asyncio.run(main('foo', bar='bar'))
      &gt;&gt;&gt; mock.assert_awaited_with('foo', bar='bar')
      &gt;&gt;&gt; mock.assert_awaited_with('other')
      Traceback (most recent call last):
      ...
      AssertionError: expected call not found.
      Expected: mock('other')
      Actual: mock('foo', bar='bar')

</pre>
</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 975)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: assert_awaited_once_with(*args, **kwargs)

    Assert that the mock was awaited exactly once and with the specified
    arguments.

      &gt;&gt;&gt; mock = AsyncMock()
      &gt;&gt;&gt; async def main(*args, **kwargs):
      ...     await mock(*args, **kwargs)
      ...
      &gt;&gt;&gt; asyncio.run(main('foo', bar='bar'))
      &gt;&gt;&gt; mock.assert_awaited_once_with('foo', bar='bar')
      &gt;&gt;&gt; asyncio.run(main('foo', bar='bar'))
      &gt;&gt;&gt; mock.assert_awaited_once_with('foo', bar='bar')
      Traceback (most recent call last):
      ...
      AssertionError: Expected mock to have been awaited once. Awaited 2 times.

</pre>
</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 992)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: assert_any_await(*args, **kwargs)

    Assert the mock has ever been awaited with the specified arguments.

      &gt;&gt;&gt; mock = AsyncMock()
      &gt;&gt;&gt; async def main(*args, **kwargs):
      ...     await mock(*args, **kwargs)
      ...
      &gt;&gt;&gt; asyncio.run(main('foo', bar='bar'))
      &gt;&gt;&gt; asyncio.run(main('hello'))
      &gt;&gt;&gt; mock.assert_any_await('foo', bar='bar')
      &gt;&gt;&gt; mock.assert_any_await('other')
      Traceback (most recent call last):
      ...
      AssertionError: mock('other') await not found

</pre>
</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1008)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: assert_has_awaits(calls, any_order=False)

    Assert the mock has been awaited with the specified calls.
    The :attr:`await_args_list` list is checked for the awaits.

    If *any_order* is false then the awaits must be
    sequential. There can be extra calls before or after the
    specified awaits.

    If *any_order* is true then the awaits can be in any order, but
    they must all appear in :attr:`await_args_list`.

      &gt;&gt;&gt; mock = AsyncMock()
      &gt;&gt;&gt; async def main(*args, **kwargs):
      ...     await mock(*args, **kwargs)
      ...
      &gt;&gt;&gt; calls = [call(&quot;foo&quot;), call(&quot;bar&quot;)]
      &gt;&gt;&gt; mock.assert_has_awaits(calls)
      Traceback (most recent call last):
      ...
      AssertionError: Awaits not found.
      Expected: [call('foo'), call('bar')]
      Actual: []
      &gt;&gt;&gt; asyncio.run(main('foo'))
      &gt;&gt;&gt; asyncio.run(main('bar'))
      &gt;&gt;&gt; mock.assert_has_awaits(calls)

</pre>
</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1035)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: assert_not_awaited()

  Assert that the mock was never awaited.

      &gt;&gt;&gt; mock = AsyncMock()
      &gt;&gt;&gt; mock.assert_not_awaited()

</pre>
</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1042)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: reset_mock(*args, **kwargs)

  See :func:`Mock.reset_mock`. Also sets :attr:`await_count` to 0,
  :attr:`await_args` to None, and clears the :attr:`await_args_list`.

</pre>
</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1047)</p>
<p>Unknown directive type &quot;attribute&quot;.</p>
<pre class="literal-block">
.. attribute:: await_count

  An integer keeping track of how many times the mock object has been awaited.

    &gt;&gt;&gt; mock = AsyncMock()
    &gt;&gt;&gt; async def main():
    ...     await mock()
    ...
    &gt;&gt;&gt; asyncio.run(main())
    &gt;&gt;&gt; mock.await_count
    1
    &gt;&gt;&gt; asyncio.run(main())
    &gt;&gt;&gt; mock.await_count
    2

</pre>
</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1062)</p>
<p>Unknown directive type &quot;attribute&quot;.</p>
<pre class="literal-block">
.. attribute:: await_args

  This is either ``None`` (if the mock hasn’t been awaited), or the arguments that
  the mock was last awaited with. Functions the same as :attr:`Mock.call_args`.

    &gt;&gt;&gt; mock = AsyncMock()
    &gt;&gt;&gt; async def main(*args):
    ...     await mock(*args)
    ...
    &gt;&gt;&gt; mock.await_args
    &gt;&gt;&gt; asyncio.run(main('foo'))
    &gt;&gt;&gt; mock.await_args
    call('foo')
    &gt;&gt;&gt; asyncio.run(main('bar'))
    &gt;&gt;&gt; mock.await_args
    call('bar')


</pre>
</div>
<div class="asyncmock-spec-none side-effect-none return-value-default wraps-none name-none spec-set-none unsafe-false kwargs system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1080)</p>
<p>Unknown directive type &quot;attribute&quot;.</p>
<pre class="literal-block">
.. attribute:: await_args_list

  This is a list of all the awaits made to the mock object in sequence (so the
  length of the list is the number of times it has been awaited). Before any
  awaits have been made it is an empty list.

    &gt;&gt;&gt; mock = AsyncMock()
    &gt;&gt;&gt; async def main(*args):
    ...     await mock(*args)
    ...
    &gt;&gt;&gt; mock.await_args_list
    []
    &gt;&gt;&gt; asyncio.run(main('foo'))
    &gt;&gt;&gt; mock.await_args_list
    [call('foo')]
    &gt;&gt;&gt; asyncio.run(main('bar'))
    &gt;&gt;&gt; mock.await_args_list
    [call('foo'), call('bar')]
</pre>
</div>
<div class="section" id="calling">
<h2>Calling</h2>
<p>Mock objects are callable. The call will return the value set as the
<a href="#id168"><span class="problematic" id="id169">:attr:`~Mock.return_value`</span></a> attribute. The default return value is a new Mock
object; it is created the first time the return value is accessed (either
explicitly or by calling the Mock) - but it is stored and the same one
returned each time.</p>
<div class="system-message" id="id168">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1103); <em><a href="#id169">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<p>Calls made to the object will be recorded in the attributes
like <a href="#id170"><span class="problematic" id="id171">:attr:`~Mock.call_args`</span></a> and <a href="#id172"><span class="problematic" id="id173">:attr:`~Mock.call_args_list`</span></a>.</p>
<div class="system-message" id="id170">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1109); <em><a href="#id171">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id172">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1109); <em><a href="#id173">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<p>If <a href="#id174"><span class="problematic" id="id175">:attr:`~Mock.side_effect`</span></a> is set then it will be called after the call has
been recorded, so if <a href="#id176"><span class="problematic" id="id177">:attr:`side_effect`</span></a> raises an exception the call is still
recorded.</p>
<div class="system-message" id="id174">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1112); <em><a href="#id175">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id176">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1112); <em><a href="#id177">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<p>The simplest way to make a mock raise an exception when called is to make
<a href="#id178"><span class="problematic" id="id179">:attr:`~Mock.side_effect`</span></a> an exception class or instance:</p>
<div class="system-message" id="id178">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1116); <em><a href="#id179">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; m = MagicMock(side_effect=IndexError)
&gt;&gt;&gt; m(1, 2, 3)
Traceback (most recent call last):
  ...
IndexError
&gt;&gt;&gt; m.mock_calls
[call(1, 2, 3)]
&gt;&gt;&gt; m.side_effect = KeyError('Bang!')
&gt;&gt;&gt; m('two', 'three', 'four')
Traceback (most recent call last):
  ...
KeyError: 'Bang!'
&gt;&gt;&gt; m.mock_calls
[call(1, 2, 3), call('two', 'three', 'four')]
</pre>
</blockquote>
<p>If <a href="#id180"><span class="problematic" id="id181">:attr:`side_effect`</span></a> is a function then whatever that function returns is what
calls to the mock return. The <a href="#id182"><span class="problematic" id="id183">:attr:`side_effect`</span></a> function is called with the
same arguments as the mock. This allows you to vary the return value of the
call dynamically, based on the input:</p>
<div class="system-message" id="id180">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1134); <em><a href="#id181">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id182">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1134); <em><a href="#id183">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def side_effect(value):
...     return value + 1
...
&gt;&gt;&gt; m = MagicMock(side_effect=side_effect)
&gt;&gt;&gt; m(1)
2
&gt;&gt;&gt; m(2)
3
&gt;&gt;&gt; m.mock_calls
[call(1), call(2)]
</pre>
</blockquote>
<p>If you want the mock to still return the default return value (a new mock), or
any set return value, then there are two ways of doing this. Either return
<a href="#id184"><span class="problematic" id="id185">:attr:`mock.return_value`</span></a> from inside <a href="#id186"><span class="problematic" id="id187">:attr:`side_effect`</span></a>, or return <a href="#id188"><span class="problematic" id="id189">:data:`DEFAULT`</span></a>:</p>
<div class="system-message" id="id184">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1150); <em><a href="#id185">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id186">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1150); <em><a href="#id187">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id188">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1150); <em><a href="#id189">backlink</a></em></p>
Unknown interpreted text role &quot;data&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; m = MagicMock()
&gt;&gt;&gt; def side_effect(*args, **kwargs):
...     return m.return_value
...
&gt;&gt;&gt; m.side_effect = side_effect
&gt;&gt;&gt; m.return_value = 3
&gt;&gt;&gt; m()
3
&gt;&gt;&gt; def side_effect(*args, **kwargs):
...     return DEFAULT
...
&gt;&gt;&gt; m.side_effect = side_effect
&gt;&gt;&gt; m()
3
</pre>
</blockquote>
<p>To remove a <a href="#id190"><span class="problematic" id="id191">:attr:`side_effect`</span></a>, and return to the default behaviour, set the
<a href="#id192"><span class="problematic" id="id193">:attr:`side_effect`</span></a> to <tt class="docutils literal">None</tt>:</p>
<div class="system-message" id="id190">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1169); <em><a href="#id191">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id192">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1169); <em><a href="#id193">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; m = MagicMock(return_value=6)
&gt;&gt;&gt; def side_effect(*args, **kwargs):
...     return 3
...
&gt;&gt;&gt; m.side_effect = side_effect
&gt;&gt;&gt; m()
3
&gt;&gt;&gt; m.side_effect = None
&gt;&gt;&gt; m()
6
</pre>
</blockquote>
<p>The <a href="#id194"><span class="problematic" id="id195">:attr:`side_effect`</span></a> can also be any iterable object. Repeated calls to the mock
will return values from the iterable (until the iterable is exhausted and
a <a href="#id196"><span class="problematic" id="id197">:exc:`StopIteration`</span></a> is raised):</p>
<div class="system-message" id="id194">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1183); <em><a href="#id195">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id196">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1183); <em><a href="#id197">backlink</a></em></p>
Unknown interpreted text role &quot;exc&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; m = MagicMock(side_effect=[1, 2, 3])
&gt;&gt;&gt; m()
1
&gt;&gt;&gt; m()
2
&gt;&gt;&gt; m()
3
&gt;&gt;&gt; m()
Traceback (most recent call last):
  ...
StopIteration
</pre>
</blockquote>
<p>If any members of the iterable are exceptions they will be raised instead of
returned:</p>
<pre class="literal-block">
&gt;&gt;&gt; iterable = (33, ValueError, 66)
&gt;&gt;&gt; m = MagicMock(side_effect=iterable)
&gt;&gt;&gt; m()
33
&gt;&gt;&gt; m()
Traceback (most recent call last):
 ...
ValueError
&gt;&gt;&gt; m()
66
</pre>
</div>
<div class="section" id="id198">
<span id="deleting-attributes"></span><h2>Deleting Attributes</h2>
<p>Mock objects create attributes on demand. This allows them to pretend to be
objects of any type.</p>
<p>You may want a mock object to return <tt class="docutils literal">False</tt> to a <a href="#id199"><span class="problematic" id="id200">:func:`hasattr`</span></a> call, or raise an
<a href="#id201"><span class="problematic" id="id202">:exc:`AttributeError`</span></a> when an attribute is fetched. You can do this by providing
an object as a <a href="#id203"><span class="problematic" id="id204">:attr:`spec`</span></a> for a mock, but that isn't always convenient.</p>
<div class="system-message" id="id199">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1222); <em><a href="#id200">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id201">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1222); <em><a href="#id202">backlink</a></em></p>
Unknown interpreted text role &quot;exc&quot;.</div>
<div class="system-message" id="id203">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1222); <em><a href="#id204">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<p>You &quot;block&quot; attributes by deleting them. Once deleted, accessing an attribute
will raise an <a href="#id205"><span class="problematic" id="id206">:exc:`AttributeError`</span></a>.</p>
<div class="system-message" id="id205">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1226); <em><a href="#id206">backlink</a></em></p>
Unknown interpreted text role &quot;exc&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mock = MagicMock()
&gt;&gt;&gt; hasattr(mock, 'm')
True
&gt;&gt;&gt; del mock.m
&gt;&gt;&gt; hasattr(mock, 'm')
False
&gt;&gt;&gt; del mock.f
&gt;&gt;&gt; mock.f
Traceback (most recent call last):
    ...
AttributeError: f
</pre>
</blockquote>
</div>
<div class="section" id="mock-names-and-the-name-attribute">
<h2>Mock names and the name attribute</h2>
<p>Since &quot;name&quot; is an argument to the <a href="#id207"><span class="problematic" id="id208">:class:`Mock`</span></a> constructor, if you want your
mock object to have a &quot;name&quot; attribute you can't just pass it in at creation
time. There are two alternatives. One option is to use
<a href="#id209"><span class="problematic" id="id210">:meth:`~Mock.configure_mock`</span></a>:</p>
<div class="system-message" id="id207">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1245); <em><a href="#id208">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id209">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1245); <em><a href="#id210">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; mock = MagicMock()
&gt;&gt;&gt; mock.configure_mock(name='my_name')
&gt;&gt;&gt; mock.name
'my_name'
</pre>
<p>A simpler option is to simply set the &quot;name&quot; attribute after mock creation:</p>
<pre class="literal-block">
&gt;&gt;&gt; mock = MagicMock()
&gt;&gt;&gt; mock.name = &quot;foo&quot;
</pre>
</div>
<div class="section" id="attaching-mocks-as-attributes">
<h2>Attaching Mocks as Attributes</h2>
<p>When you attach a mock as an attribute of another mock (or as the return
value) it becomes a &quot;child&quot; of that mock. Calls to the child are recorded in
the <a href="#id211"><span class="problematic" id="id212">:attr:`~Mock.method_calls`</span></a> and <a href="#id213"><span class="problematic" id="id214">:attr:`~Mock.mock_calls`</span></a> attributes of the
parent. This is useful for configuring child mocks and then attaching them to
the parent, or for attaching mocks to a parent that records all calls to the
children and allows you to make assertions about the order of calls between
mocks:</p>
<div class="system-message" id="id211">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1264); <em><a href="#id212">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id213">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1264); <em><a href="#id214">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; parent = MagicMock()
&gt;&gt;&gt; child1 = MagicMock(return_value=None)
&gt;&gt;&gt; child2 = MagicMock(return_value=None)
&gt;&gt;&gt; parent.child1 = child1
&gt;&gt;&gt; parent.child2 = child2
&gt;&gt;&gt; child1(1)
&gt;&gt;&gt; child2(2)
&gt;&gt;&gt; parent.mock_calls
[call.child1(1), call.child2(2)]
</pre>
</blockquote>
<p>The exception to this is if the mock has a name. This allows you to prevent
the &quot;parenting&quot; if for some reason you don't want it to happen.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mock = MagicMock()
&gt;&gt;&gt; not_a_child = MagicMock(name='not-a-child')
&gt;&gt;&gt; mock.attribute = not_a_child
&gt;&gt;&gt; mock.attribute()
&lt;MagicMock name='not-a-child()' id='...'&gt;
&gt;&gt;&gt; mock.mock_calls
[]
</pre>
</blockquote>
<p>Mocks created for you by <a href="#id215"><span class="problematic" id="id216">:func:`patch`</span></a> are automatically given names. To
attach mocks that have names to a parent you use the <a href="#id217"><span class="problematic" id="id218">:meth:`~Mock.attach_mock`</span></a>
method:</p>
<div class="system-message" id="id215">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1293); <em><a href="#id216">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id217">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1293); <em><a href="#id218">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; thing1 = object()
&gt;&gt;&gt; thing2 = object()
&gt;&gt;&gt; parent = MagicMock()
&gt;&gt;&gt; with patch('__main__.thing1', return_value=None) as child1:
...     with patch('__main__.thing2', return_value=None) as child2:
...         parent.attach_mock(child1, 'child1')
...         parent.attach_mock(child2, 'child2')
...         child1('one')
...         child2('two')
...
&gt;&gt;&gt; parent.mock_calls
[call.child1('one'), call.child2('two')]
</pre>
<table class="docutils footnote" frame="void" id="id219" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id57">[1]</a></td><td><p class="first">The only exceptions are magic methods and attributes (those that have
leading and trailing double underscores). Mock doesn't create these but
instead raises an <a href="#id220"><span class="problematic" id="id221">:exc:`AttributeError`</span></a>. This is because the interpreter
will often implicitly request these methods, and gets <em>very</em> confused to
get a new Mock object when it expects a magic method. If you need magic
method support see <a href="#id222"><span class="problematic" id="id223">:ref:`magic methods &lt;magic-methods&gt;`</span></a>.</p>
<div class="system-message" id="id220">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1311); <em><a href="#id221">backlink</a></em></p>
Unknown interpreted text role &quot;exc&quot;.</div>
<div class="last system-message" id="id222">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1311); <em><a href="#id223">backlink</a></em></p>
Unknown interpreted text role &quot;ref&quot;.</div>
</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="the-patchers">
<h1>The patchers</h1>
<p>The patch decorators are used for patching objects only within the scope of
the function they decorate. They automatically handle the unpatching for you,
even if exceptions are raised. All of these functions can also be used in with
statements or as class decorators.</p>
<div class="section" id="patch">
<h2>patch</h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The key is to do the patching in the right namespace. See the section <a class="reference internal" href="#id322">where to patch</a>.</p>
</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1335)</p>
<p>Unknown directive type &quot;function&quot;.</p>
<pre class="literal-block">
.. function:: patch(target, new=DEFAULT, spec=None, create=False, spec_set=None, autospec=None, new_callable=None, **kwargs)

    :func:`patch` acts as a function decorator, class decorator or a context
    manager. Inside the body of the function or with statement, the *target*
    is patched with a *new* object. When the function/with statement exits
    the patch is undone.

    If *new* is omitted, then the target is replaced with an
    :class:`AsyncMock` if the patched object is an async function or
    a :class:`MagicMock` otherwise.
    If :func:`patch` is used as a decorator and *new* is
    omitted, the created mock is passed in as an extra argument to the
    decorated function. If :func:`patch` is used as a context manager the created
    mock is returned by the context manager.

    *target* should be a string in the form ``'package.module.ClassName'``. The
    *target* is imported and the specified object replaced with the *new*
    object, so the *target* must be importable from the environment you are
    calling :func:`patch` from. The target is imported when the decorated function
    is executed, not at decoration time.

    The *spec* and *spec_set* keyword arguments are passed to the :class:`MagicMock`
    if patch is creating one for you.

    In addition you can pass ``spec=True`` or ``spec_set=True``, which causes
    patch to pass in the object being mocked as the spec/spec_set object.

    *new_callable* allows you to specify a different class, or callable object,
    that will be called to create the *new* object. By default :class:`AsyncMock`
    is used for async functions and :class:`MagicMock` for the rest.

    A more powerful form of *spec* is *autospec*. If you set ``autospec=True``
    then the mock will be created with a spec from the object being replaced.
    All attributes of the mock will also have the spec of the corresponding
    attribute of the object being replaced. Methods and functions being mocked
    will have their arguments checked and will raise a :exc:`TypeError` if they are
    called with the wrong signature. For mocks
    replacing a class, their return value (the 'instance') will have the same
    spec as the class. See the :func:`create_autospec` function and
    :ref:`auto-speccing`.

    Instead of ``autospec=True`` you can pass ``autospec=some_object`` to use an
    arbitrary object as the spec instead of the one being replaced.

    By default :func:`patch` will fail to replace attributes that don't exist.
    If you pass in ``create=True``, and the attribute doesn't exist, patch will
    create the attribute for you when the patched function is called, and delete
    it again after the patched function has exited. This is useful for writing
    tests against attributes that your production code creates at runtime. It is
    off by default because it can be dangerous. With it switched on you can
    write passing tests against APIs that don't actually exist!

    .. note::

        .. versionchanged:: 3.5
           If you are patching builtins in a module then you don't
           need to pass ``create=True``, it will be added by default.

    Patch can be used as a :class:`TestCase` class decorator. It works by
    decorating each test method in the class. This reduces the boilerplate
    code when your test methods share a common patchings set. :func:`patch` finds
    tests by looking for method names that start with ``patch.TEST_PREFIX``.
    By default this is ``'test'``, which matches the way :mod:`unittest` finds tests.
    You can specify an alternative prefix by setting ``patch.TEST_PREFIX``.

    Patch can be used as a context manager, with the with statement. Here the
    patching applies to the indented block after the with statement. If you
    use &quot;as&quot; then the patched object will be bound to the name after the
    &quot;as&quot;; very useful if :func:`patch` is creating a mock object for you.

    :func:`patch` takes arbitrary keyword arguments. These will be passed to
    :class:`AsyncMock` if the patched object is asynchronous, to
    :class:`MagicMock` otherwise or to *new_callable* if specified.

    ``patch.dict(...)``, ``patch.multiple(...)`` and ``patch.object(...)`` are
    available for alternate use-cases.

</pre>
</div>
<p><a href="#id224"><span class="problematic" id="id225">:func:`patch`</span></a> as function decorator, creating the mock for you and passing it into
the decorated function:</p>
<div class="system-message" id="id224">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1412); <em><a href="#id225">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; &#64;patch('__main__.SomeClass')
... def function(normal_argument, mock_class):
...     print(mock_class is SomeClass)
...
&gt;&gt;&gt; function(None)
True
</pre>
<p>Patching a class replaces the class with a <a href="#id226"><span class="problematic" id="id227">:class:`MagicMock`</span></a> <em>instance</em>. If the
class is instantiated in the code under test then it will be the
<a href="#id228"><span class="problematic" id="id229">:attr:`~Mock.return_value`</span></a> of the mock that will be used.</p>
<div class="system-message" id="id226">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1422); <em><a href="#id227">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id228">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1422); <em><a href="#id229">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<p>If the class is instantiated multiple times you could use
<a href="#id230"><span class="problematic" id="id231">:attr:`~Mock.side_effect`</span></a> to return a new mock each time. Alternatively you
can set the <em>return_value</em> to be anything you want.</p>
<div class="system-message" id="id230">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1426); <em><a href="#id231">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<p>To configure return values on methods of <em>instances</em> on the patched class
you must do this on the <a href="#id232"><span class="problematic" id="id233">:attr:`return_value`</span></a>. For example:</p>
<div class="system-message" id="id232">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1430); <em><a href="#id233">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; class Class:
...     def method(self):
...         pass
...
&gt;&gt;&gt; with patch('__main__.Class') as MockClass:
...     instance = MockClass.return_value
...     instance.method.return_value = 'foo'
...     assert Class() is instance
...     assert Class().method() == 'foo'
...
</pre>
<p>If you use <em>spec</em> or <em>spec_set</em> and <a href="#id234"><span class="problematic" id="id235">:func:`patch`</span></a> is replacing a <em>class</em>, then the
return value of the created mock will have the same spec.</p>
<div class="system-message" id="id234">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1444); <em><a href="#id235">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; Original = Class
&gt;&gt;&gt; patcher = patch('__main__.Class', spec=True)
&gt;&gt;&gt; MockClass = patcher.start()
&gt;&gt;&gt; instance = MockClass()
&gt;&gt;&gt; assert isinstance(instance, Original)
&gt;&gt;&gt; patcher.stop()
</pre>
<p>The <em>new_callable</em> argument is useful where you want to use an alternative
class to the default <a href="#id236"><span class="problematic" id="id237">:class:`MagicMock`</span></a> for the created mock. For example, if
you wanted a <a href="#id238"><span class="problematic" id="id239">:class:`NonCallableMock`</span></a> to be used:</p>
<div class="system-message" id="id236">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1454); <em><a href="#id237">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id238">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1454); <em><a href="#id239">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; thing = object()
&gt;&gt;&gt; with patch('__main__.thing', new_callable=NonCallableMock) as mock_thing:
...     assert thing is mock_thing
...     thing()
...
Traceback (most recent call last):
  ...
TypeError: 'NonCallableMock' object is not callable
</pre>
<p>Another use case might be to replace an object with an <a href="#id240"><span class="problematic" id="id241">:class:`io.StringIO`</span></a> instance:</p>
<div class="system-message" id="id240">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1467); <em><a href="#id241">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; from io import StringIO
&gt;&gt;&gt; def foo():
...     print('Something')
...
&gt;&gt;&gt; &#64;patch('sys.stdout', new_callable=StringIO)
... def test(mock_stdout):
...     foo()
...     assert mock_stdout.getvalue() == 'Something\n'
...
&gt;&gt;&gt; test()
</pre>
<p>When <a href="#id242"><span class="problematic" id="id243">:func:`patch`</span></a> is creating a mock for you, it is common that the first thing
you need to do is to configure the mock. Some of that configuration can be done
in the call to patch. Any arbitrary keywords you pass into the call will be
used to set attributes on the created mock:</p>
<div class="system-message" id="id242">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1480); <em><a href="#id243">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; patcher = patch('__main__.thing', first='one', second='two')
&gt;&gt;&gt; mock_thing = patcher.start()
&gt;&gt;&gt; mock_thing.first
'one'
&gt;&gt;&gt; mock_thing.second
'two'
</pre>
<p>As well as attributes on the created mock attributes, like the
<a href="#id244"><span class="problematic" id="id245">:attr:`~Mock.return_value`</span></a> and <a href="#id246"><span class="problematic" id="id247">:attr:`~Mock.side_effect`</span></a>, of child mocks can
also be configured. These aren't syntactically valid to pass in directly as
keyword arguments, but a dictionary with these as keys can still be expanded
into a <a href="#id248"><span class="problematic" id="id249">:func:`patch`</span></a> call using <tt class="docutils literal">**</tt>:</p>
<div class="system-message" id="id244">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1492); <em><a href="#id245">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id246">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1492); <em><a href="#id247">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id248">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1492); <em><a href="#id249">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; config = {'method.return_value': 3, 'other.side_effect': KeyError}
&gt;&gt;&gt; patcher = patch('__main__.thing', **config)
&gt;&gt;&gt; mock_thing = patcher.start()
&gt;&gt;&gt; mock_thing.method()
3
&gt;&gt;&gt; mock_thing.other()
Traceback (most recent call last):
  ...
KeyError
</pre>
<p>By default, attempting to patch a function in a module (or a method or an
attribute in a class) that does not exist will fail with <a href="#id250"><span class="problematic" id="id251">:exc:`AttributeError`</span></a>:</p>
<div class="system-message" id="id250">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1508); <em><a href="#id251">backlink</a></em></p>
Unknown interpreted text role &quot;exc&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; &#64;patch('sys.non_existing_attribute', 42)
... def test():
...     assert sys.non_existing_attribute == 42
...
&gt;&gt;&gt; test()
Traceback (most recent call last):
  ...
AttributeError: &lt;module 'sys' (built-in)&gt; does not have the attribute 'non_existing'
</pre>
<p>but adding <tt class="docutils literal">create=True</tt> in the call to <a href="#id252"><span class="problematic" id="id253">:func:`patch`</span></a> will make the previous example
work as expected:</p>
<div class="system-message" id="id252">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1520); <em><a href="#id253">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; &#64;patch('sys.non_existing_attribute', 42, create=True)
... def test(mock_stdout):
...     assert sys.non_existing_attribute == 42
...
&gt;&gt;&gt; test()
</pre>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1529)</p>
<p>Unknown directive type &quot;versionchanged&quot;.</p>
<pre class="literal-block">
.. versionchanged:: 3.8

    :func:`patch` now returns an :class:`AsyncMock` if the target is an async function.


</pre>
</div>
</div>
<div class="section" id="patch-object">
<h2>patch.object</h2>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1537)</p>
<p>Unknown directive type &quot;function&quot;.</p>
<pre class="literal-block">
.. function:: patch.object(target, attribute, new=DEFAULT, spec=None, create=False, spec_set=None, autospec=None, new_callable=None, **kwargs)

    patch the named member (*attribute*) on an object (*target*) with a mock
    object.

    :func:`patch.object` can be used as a decorator, class decorator or a context
    manager. Arguments *new*, *spec*, *create*, *spec_set*, *autospec* and
    *new_callable* have the same meaning as for :func:`patch`. Like :func:`patch`,
    :func:`patch.object` takes arbitrary keyword arguments for configuring the mock
    object it creates.

    When used as a class decorator :func:`patch.object` honours ``patch.TEST_PREFIX``
    for choosing which methods to wrap.

</pre>
</div>
<p>You can either call <a href="#id254"><span class="problematic" id="id255">:func:`patch.object`</span></a> with three arguments or two arguments. The
three argument form takes the object to be patched, the attribute name and the
object to replace the attribute with.</p>
<div class="system-message" id="id254">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1551); <em><a href="#id255">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<p>When calling with the two argument form you omit the replacement object, and a
mock is created for you and passed in as an extra argument to the decorated
function:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; &#64;patch.object(SomeClass, 'class_method')
... def test(mock_method):
...     SomeClass.class_method(3)
...     mock_method.assert_called_with(3)
...
&gt;&gt;&gt; test()
</pre>
</blockquote>
<p><em>spec</em>, <em>create</em> and the other arguments to <a href="#id256"><span class="problematic" id="id257">:func:`patch.object`</span></a> have the same
meaning as they do for <a href="#id258"><span class="problematic" id="id259">:func:`patch`</span></a>.</p>
<div class="system-message" id="id256">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1566); <em><a href="#id257">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id258">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1566); <em><a href="#id259">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
</div>
<div class="section" id="patch-dict">
<h2>patch.dict</h2>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1573)</p>
<p>Unknown directive type &quot;function&quot;.</p>
<pre class="literal-block">
.. function:: patch.dict(in_dict, values=(), clear=False, **kwargs)

    Patch a dictionary, or dictionary like object, and restore the dictionary
    to its original state after the test.

    *in_dict* can be a dictionary or a mapping like container. If it is a
    mapping then it must at least support getting, setting and deleting items
    plus iterating over keys.

    *in_dict* can also be a string specifying the name of the dictionary, which
    will then be fetched by importing it.

    *values* can be a dictionary of values to set in the dictionary. *values*
    can also be an iterable of ``(key, value)`` pairs.

    If *clear* is true then the dictionary will be cleared before the new
    values are set.

    :func:`patch.dict` can also be called with arbitrary keyword arguments to set
    values in the dictionary.

    .. versionchanged:: 3.8

        :func:`patch.dict` now returns the patched dictionary when used as a context
        manager.

</pre>
</div>
<p><a href="#id260"><span class="problematic" id="id261">:func:`patch.dict`</span></a> can be used as a context manager, decorator or class
decorator:</p>
<div class="system-message" id="id260">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1599); <em><a href="#id261">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; foo = {}
&gt;&gt;&gt; &#64;patch.dict(foo, {'newkey': 'newvalue'})
... def test():
...     assert foo == {'newkey': 'newvalue'}
&gt;&gt;&gt; test()
&gt;&gt;&gt; assert foo == {}
</pre>
</blockquote>
<p>When used as a class decorator <a href="#id262"><span class="problematic" id="id263">:func:`patch.dict`</span></a> honours
<tt class="docutils literal">patch.TEST_PREFIX</tt> (default to <tt class="docutils literal">'test'</tt>) for choosing which methods to wrap:</p>
<div class="system-message" id="id262">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1609); <em><a href="#id263">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import os
&gt;&gt;&gt; import unittest
&gt;&gt;&gt; from unittest.mock import patch
&gt;&gt;&gt; &#64;patch.dict('os.environ', {'newkey': 'newvalue'})
... class TestSample(unittest.TestCase):
...     def test_sample(self):
...         self.assertEqual(os.environ['newkey'], 'newvalue')
</pre>
</blockquote>
<p>If you want to use a different prefix for your test, you can inform the
patchers of the different prefix by setting <tt class="docutils literal">patch.TEST_PREFIX</tt>. For
more details about how to change the value of see <a href="#id264"><span class="problematic" id="id265">:ref:`test-prefix`</span></a>.</p>
<div class="system-message" id="id264">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1620); <em><a href="#id265">backlink</a></em></p>
Unknown interpreted text role &quot;ref&quot;.</div>
<p><a href="#id266"><span class="problematic" id="id267">:func:`patch.dict`</span></a> can be used to add members to a dictionary, or simply let a test
change a dictionary, and ensure the dictionary is restored when the test
ends.</p>
<div class="system-message" id="id266">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1624); <em><a href="#id267">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; foo = {}
&gt;&gt;&gt; with patch.dict(foo, {'newkey': 'newvalue'}) as patched_foo:
...     assert foo == {'newkey': 'newvalue'}
...     assert patched_foo == {'newkey': 'newvalue'}
...     # You can add, update or delete keys of foo (or patched_foo, it's the same dict)
...     patched_foo['spam'] = 'eggs'
...
&gt;&gt;&gt; assert foo == {}
&gt;&gt;&gt; assert patched_foo == {}
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; import os
&gt;&gt;&gt; with patch.dict('os.environ', {'newkey': 'newvalue'}):
...     print(os.environ['newkey'])
...
newvalue
&gt;&gt;&gt; assert 'newkey' not in os.environ
</pre>
</blockquote>
<p>Keywords can be used in the <a href="#id268"><span class="problematic" id="id269">:func:`patch.dict`</span></a> call to set values in the dictionary:</p>
<div class="system-message" id="id268">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1645); <em><a href="#id269">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mymodule = MagicMock()
&gt;&gt;&gt; mymodule.function.return_value = 'fish'
&gt;&gt;&gt; with patch.dict('sys.modules', mymodule=mymodule):
...     import mymodule
...     mymodule.function('some', 'args')
...
'fish'
</pre>
</blockquote>
<p><a href="#id270"><span class="problematic" id="id271">:func:`patch.dict`</span></a> can be used with dictionary like objects that aren't actually
dictionaries. At the very minimum they must support item getting, setting,
deleting and either iteration or membership test. This corresponds to the
magic methods <a href="#id272"><span class="problematic" id="id273">:meth:`__getitem__`</span></a>, <a href="#id274"><span class="problematic" id="id275">:meth:`__setitem__`</span></a>, <a href="#id276"><span class="problematic" id="id277">:meth:`__delitem__`</span></a> and either
<a href="#id278"><span class="problematic" id="id279">:meth:`__iter__`</span></a> or <a href="#id280"><span class="problematic" id="id281">:meth:`__contains__`</span></a>.</p>
<div class="system-message" id="id270">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1655); <em><a href="#id271">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id272">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1655); <em><a href="#id273">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id274">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1655); <em><a href="#id275">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id276">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1655); <em><a href="#id277">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id278">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1655); <em><a href="#id279">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id280">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1655); <em><a href="#id281">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class Container:
...     def __init__(self):
...         self.values = {}
...     def __getitem__(self, name):
...         return self.values[name]
...     def __setitem__(self, name, value):
...         self.values[name] = value
...     def __delitem__(self, name):
...         del self.values[name]
...     def __iter__(self):
...         return iter(self.values)
...
&gt;&gt;&gt; thing = Container()
&gt;&gt;&gt; thing['one'] = 1
&gt;&gt;&gt; with patch.dict(thing, one=2, two=3):
...     assert thing['one'] == 2
...     assert thing['two'] == 3
...
&gt;&gt;&gt; assert thing['one'] == 1
&gt;&gt;&gt; assert list(thing) == ['one']
</pre>
</blockquote>
</div>
<div class="section" id="patch-multiple">
<h2>patch.multiple</h2>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1686)</p>
<p>Unknown directive type &quot;function&quot;.</p>
<pre class="literal-block">
.. function:: patch.multiple(target, spec=None, create=False, spec_set=None, autospec=None, new_callable=None, **kwargs)

    Perform multiple patches in a single call. It takes the object to be
    patched (either as an object or a string to fetch the object by importing)
    and keyword arguments for the patches::

        with patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):
            ...

    Use :data:`DEFAULT` as the value if you want :func:`patch.multiple` to create
    mocks for you. In this case the created mocks are passed into a decorated
    function by keyword, and a dictionary is returned when :func:`patch.multiple` is
    used as a context manager.

    :func:`patch.multiple` can be used as a decorator, class decorator or a context
    manager. The arguments *spec*, *spec_set*, *create*, *autospec* and
    *new_callable* have the same meaning as for :func:`patch`. These arguments will
    be applied to *all* patches done by :func:`patch.multiple`.

    When used as a class decorator :func:`patch.multiple` honours ``patch.TEST_PREFIX``
    for choosing which methods to wrap.

</pre>
</div>
<p>If you want <a href="#id282"><span class="problematic" id="id283">:func:`patch.multiple`</span></a> to create mocks for you, then you can use
<a href="#id284"><span class="problematic" id="id285">:data:`DEFAULT`</span></a> as the value. If you use <a href="#id286"><span class="problematic" id="id287">:func:`patch.multiple`</span></a> as a decorator
then the created mocks are passed into the decorated function by keyword.</p>
<div class="system-message" id="id282">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1708); <em><a href="#id283">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id284">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1708); <em><a href="#id285">backlink</a></em></p>
Unknown interpreted text role &quot;data&quot;.</div>
<div class="system-message" id="id286">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1708); <em><a href="#id287">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; thing = object()
&gt;&gt;&gt; other = object()

&gt;&gt;&gt; &#64;patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)
... def test_function(thing, other):
...     assert isinstance(thing, MagicMock)
...     assert isinstance(other, MagicMock)
...
&gt;&gt;&gt; test_function()
</pre>
<p><a href="#id288"><span class="problematic" id="id289">:func:`patch.multiple`</span></a> can be nested with other <tt class="docutils literal">patch</tt> decorators, but put arguments
passed by keyword <em>after</em> any of the standard arguments created by <a href="#id290"><span class="problematic" id="id291">:func:`patch`</span></a>:</p>
<div class="system-message" id="id288">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1722); <em><a href="#id289">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id290">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1722); <em><a href="#id291">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; &#64;patch('sys.exit')
... &#64;patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)
... def test_function(mock_exit, other, thing):
...     assert 'other' in repr(other)
...     assert 'thing' in repr(thing)
...     assert 'exit' in repr(mock_exit)
...
&gt;&gt;&gt; test_function()
</pre>
<p>If <a href="#id292"><span class="problematic" id="id293">:func:`patch.multiple`</span></a> is used as a context manager, the value returned by the
context manager is a dictionary where created mocks are keyed by name:</p>
<div class="system-message" id="id292">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1734); <em><a href="#id293">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; with patch.multiple('__main__', thing=DEFAULT, other=DEFAULT) as values:
...     assert 'other' in repr(values['other'])
...     assert 'thing' in repr(values['thing'])
...     assert values['thing'] is thing
...     assert values['other'] is other
...
</pre>
</div>
<div class="section" id="patch-methods-start-and-stop">
<span id="start-and-stop"></span><h2>patch methods: start and stop</h2>
<p>All the patchers have <a href="#id294"><span class="problematic" id="id295">:meth:`start`</span></a> and <a href="#id296"><span class="problematic" id="id297">:meth:`stop`</span></a> methods. These make it simpler to do
patching in <tt class="docutils literal">setUp</tt> methods or where you want to do multiple patches without
nesting decorators or with statements.</p>
<div class="system-message" id="id294">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1750); <em><a href="#id295">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id296">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1750); <em><a href="#id297">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<p>To use them call <a href="#id298"><span class="problematic" id="id299">:func:`patch`</span></a>, <a href="#id300"><span class="problematic" id="id301">:func:`patch.object`</span></a> or <a href="#id302"><span class="problematic" id="id303">:func:`patch.dict`</span></a> as
normal and keep a reference to the returned <tt class="docutils literal">patcher</tt> object. You can then
call <a href="#id304"><span class="problematic" id="id305">:meth:`start`</span></a> to put the patch in place and <a href="#id306"><span class="problematic" id="id307">:meth:`stop`</span></a> to undo it.</p>
<div class="system-message" id="id298">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1754); <em><a href="#id299">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id300">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1754); <em><a href="#id301">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id302">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1754); <em><a href="#id303">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id304">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1754); <em><a href="#id305">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id306">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1754); <em><a href="#id307">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<p>If you are using <a href="#id308"><span class="problematic" id="id309">:func:`patch`</span></a> to create a mock for you then it will be returned by
the call to <tt class="docutils literal">patcher.start</tt>.</p>
<div class="system-message" id="id308">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1758); <em><a href="#id309">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; patcher = patch('package.module.ClassName')
&gt;&gt;&gt; from package import module
&gt;&gt;&gt; original = module.ClassName
&gt;&gt;&gt; new_mock = patcher.start()
&gt;&gt;&gt; assert module.ClassName is not original
&gt;&gt;&gt; assert module.ClassName is new_mock
&gt;&gt;&gt; patcher.stop()
&gt;&gt;&gt; assert module.ClassName is original
&gt;&gt;&gt; assert module.ClassName is not new_mock
</pre>
<p>A typical use case for this might be for doing multiple patches in the <tt class="docutils literal">setUp</tt>
method of a <a href="#id310"><span class="problematic" id="id311">:class:`TestCase`</span></a>:</p>
<div class="system-message" id="id310">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1772); <em><a href="#id311">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; class MyTest(unittest.TestCase):
...     def setUp(self):
...         self.patcher1 = patch('package.module.Class1')
...         self.patcher2 = patch('package.module.Class2')
...         self.MockClass1 = self.patcher1.start()
...         self.MockClass2 = self.patcher2.start()
...
...     def tearDown(self):
...         self.patcher1.stop()
...         self.patcher2.stop()
...
...     def test_something(self):
...         assert package.module.Class1 is self.MockClass1
...         assert package.module.Class2 is self.MockClass2
...
&gt;&gt;&gt; MyTest('test_something').run()
</pre>
<div class="admonition caution">
<p class="first admonition-title">Caution!</p>
<p>If you use this technique you must ensure that the patching is &quot;undone&quot; by
calling <tt class="docutils literal">stop</tt>. This can be fiddlier than you might think, because if an
exception is raised in the <tt class="docutils literal">setUp</tt> then <tt class="docutils literal">tearDown</tt> is not called.
<a href="#id312"><span class="problematic" id="id313">:meth:`unittest.TestCase.addCleanup`</span></a> makes this easier:</p>
<div class="system-message" id="id312">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1794); <em><a href="#id313">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; class MyTest(unittest.TestCase):
...     def setUp(self):
...         patcher = patch('package.module.Class')
...         self.MockClass = patcher.start()
...         self.addCleanup(patcher.stop)
...
...     def test_something(self):
...         assert package.module.Class is self.MockClass
...
</pre>
<p class="last">As an added bonus you no longer need to keep a reference to the <tt class="docutils literal">patcher</tt>
object.</p>
</div>
<p>It is also possible to stop all patches which have been started by using
<a href="#id314"><span class="problematic" id="id315">:func:`patch.stopall`</span></a>.</p>
<div class="system-message" id="id314">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1812); <em><a href="#id315">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1815)</p>
<p>Unknown directive type &quot;function&quot;.</p>
<pre class="literal-block">
.. function:: patch.stopall

    Stop all active patches. Only stops patches started with ``start``.


</pre>
</div>
</div>
<div class="section" id="id316">
<span id="patch-builtins"></span><h2>patch builtins</h2>
<p>You can patch any builtins within a module. The following example patches
builtin <a href="#id317"><span class="problematic" id="id318">:func:`ord`</span></a>:</p>
<div class="system-message" id="id317">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1824); <em><a href="#id318">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; &#64;patch('__main__.ord')
... def test(mock_ord):
...     mock_ord.return_value = 101
...     print(ord('c'))
...
&gt;&gt;&gt; test()
101
</pre>
</div>
<div class="section" id="id319">
<span id="test-prefix"></span><h2>TEST_PREFIX</h2>
<p>All of the patchers can be used as class decorators. When used in this way
they wrap every test method on the class. The patchers recognise methods that
start with <tt class="docutils literal">'test'</tt> as being test methods. This is the same way that the
<a href="#id320"><span class="problematic" id="id321">:class:`unittest.TestLoader`</span></a> finds test methods by default.</p>
<div class="system-message" id="id320">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1841); <em><a href="#id321">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<p>It is possible that you want to use a different prefix for your tests. You can
inform the patchers of the different prefix by setting <tt class="docutils literal">patch.TEST_PREFIX</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; patch.TEST_PREFIX = 'foo'
&gt;&gt;&gt; value = 3
&gt;&gt;&gt;
&gt;&gt;&gt; &#64;patch('__main__.value', 'not three')
... class Thing:
...     def foo_one(self):
...         print(value)
...     def foo_two(self):
...         print(value)
...
&gt;&gt;&gt;
&gt;&gt;&gt; Thing().foo_one()
not three
&gt;&gt;&gt; Thing().foo_two()
not three
&gt;&gt;&gt; value
3
</pre>
</div>
<div class="section" id="nesting-patch-decorators">
<h2>Nesting Patch Decorators</h2>
<p>If you want to perform multiple patches then you can simply stack up the
decorators.</p>
<p>You can stack up multiple patch decorators using this pattern:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; &#64;patch.object(SomeClass, 'class_method')
... &#64;patch.object(SomeClass, 'static_method')
... def test(mock1, mock2):
...     assert SomeClass.static_method is mock1
...     assert SomeClass.class_method is mock2
...     SomeClass.static_method('foo')
...     SomeClass.class_method('bar')
...     return mock1, mock2
...
&gt;&gt;&gt; mock1, mock2 = test()
&gt;&gt;&gt; mock1.assert_called_once_with('foo')
&gt;&gt;&gt; mock2.assert_called_once_with('bar')
</pre>
</blockquote>
<p>Note that the decorators are applied from the bottom upwards. This is the
standard way that Python applies decorators. The order of the created mocks
passed into your test function matches this order.</p>
</div>
<div class="section" id="id322">
<span id="where-to-patch"></span><h2>Where to patch</h2>
<p><a href="#id323"><span class="problematic" id="id324">:func:`patch`</span></a> works by (temporarily) changing the object that a <em>name</em> points to with
another one. There can be many names pointing to any individual object, so
for patching to work you must ensure that you patch the name used by the system
under test.</p>
<div class="system-message" id="id323">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1900); <em><a href="#id324">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<p>The basic principle is that you patch where an object is <em>looked up</em>, which
is not necessarily the same place as where it is defined. A couple of
examples will help to clarify this.</p>
<p>Imagine we have a project that we want to test with the following structure:</p>
<pre class="literal-block">
a.py
    -&gt; Defines SomeClass

b.py
    -&gt; from a import SomeClass
    -&gt; some_function instantiates SomeClass
</pre>
<p>Now we want to test <tt class="docutils literal">some_function</tt> but we want to mock out <tt class="docutils literal">SomeClass</tt> using
<a href="#id325"><span class="problematic" id="id326">:func:`patch`</span></a>. The problem is that when we import module b, which we will have to
do then it imports <tt class="docutils literal">SomeClass</tt> from module a. If we use <a href="#id327"><span class="problematic" id="id328">:func:`patch`</span></a> to mock out
<tt class="docutils literal">a.SomeClass</tt> then it will have no effect on our test; module b already has a
reference to the <em>real</em> <tt class="docutils literal">SomeClass</tt> and it looks like our patching had no
effect.</p>
<div class="system-message" id="id325">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1918); <em><a href="#id326">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id327">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1918); <em><a href="#id328">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<p>The key is to patch out <tt class="docutils literal">SomeClass</tt> where it is used (or where it is looked up).
In this case <tt class="docutils literal">some_function</tt> will actually look up <tt class="docutils literal">SomeClass</tt> in module b,
where we have imported it. The patching should look like:</p>
<pre class="literal-block">
&#64;patch('b.SomeClass')
</pre>
<p>However, consider the alternative scenario where instead of <tt class="docutils literal">from a import
SomeClass</tt> module b does <tt class="docutils literal">import a</tt> and <tt class="docutils literal">some_function</tt> uses <tt class="docutils literal">a.SomeClass</tt>. Both
of these import forms are common. In this case the class we want to patch is
being looked up in the module and so we have to patch <tt class="docutils literal">a.SomeClass</tt> instead:</p>
<pre class="literal-block">
&#64;patch('a.SomeClass')
</pre>
</div>
<div class="section" id="patching-descriptors-and-proxy-objects">
<h2>Patching Descriptors and Proxy Objects</h2>
<p>Both <a class="reference internal" href="#patch">patch</a> and <a class="reference internal" href="#patch-object">patch.object</a> correctly patch and restore descriptors: class
methods, static methods and properties. You should patch these on the <em>class</em>
rather than an instance. They also work with <em>some</em> objects
that proxy attribute access, like the <a class="reference external" href="http://www.voidspace.org.uk/python/weblog/arch_d7_2010_12_04.shtml#e1198">django settings object</a>.</p>
</div>
</div>
<div class="section" id="magicmock-and-magic-method-support">
<h1>MagicMock and magic method support</h1>
<div class="section" id="mocking-magic-methods">
<span id="magic-methods"></span><h2>Mocking Magic Methods</h2>
<p><a href="#id329"><span class="problematic" id="id330">:class:`Mock`</span></a> supports mocking the Python protocol methods, also known as
&quot;magic methods&quot;. This allows mock objects to replace containers or other
objects that implement Python protocols.</p>
<div class="system-message" id="id329">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1957); <em><a href="#id330">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<p>Because magic methods are looked up differently from normal methods <a class="footnote-reference" href="#id363" id="id331">[2]</a>, this
support has been specially implemented. This means that only specific magic
methods are supported. The supported list includes <em>almost</em> all of them. If
there are any missing that you need please let us know.</p>
<p>You mock magic methods by setting the method you are interested in to a function
or a mock instance. If you are using a function then it <em>must</em> take <tt class="docutils literal">self</tt> as
the first argument <a class="footnote-reference" href="#id364" id="id332">[3]</a>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def __str__(self):
...     return 'fooble'
...
&gt;&gt;&gt; mock = Mock()
&gt;&gt;&gt; mock.__str__ = __str__
&gt;&gt;&gt; str(mock)
'fooble'
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; mock = Mock()
&gt;&gt;&gt; mock.__str__ = Mock()
&gt;&gt;&gt; mock.__str__.return_value = 'fooble'
&gt;&gt;&gt; str(mock)
'fooble'
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; mock = Mock()
&gt;&gt;&gt; mock.__iter__ = Mock(return_value=iter([]))
&gt;&gt;&gt; list(mock)
[]
</pre>
</blockquote>
<p>One use case for this is for mocking objects used as context managers in a
<a href="#id333"><span class="problematic" id="id334">:keyword:`with`</span></a> statement:</p>
<div class="system-message" id="id333">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 1989); <em><a href="#id334">backlink</a></em></p>
Unknown interpreted text role &quot;keyword&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mock = Mock()
&gt;&gt;&gt; mock.__enter__ = Mock(return_value='foo')
&gt;&gt;&gt; mock.__exit__ = Mock(return_value=False)
&gt;&gt;&gt; with mock as m:
...     assert m == 'foo'
...
&gt;&gt;&gt; mock.__enter__.assert_called_with()
&gt;&gt;&gt; mock.__exit__.assert_called_with(None, None, None)
</pre>
</blockquote>
<p>Calls to magic methods do not appear in <a href="#id335"><span class="problematic" id="id336">:attr:`~Mock.method_calls`</span></a>, but they
are recorded in <a href="#id337"><span class="problematic" id="id338">:attr:`~Mock.mock_calls`</span></a>.</p>
<div class="system-message" id="id335">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2001); <em><a href="#id336">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id337">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2001); <em><a href="#id338">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If you use the <em>spec</em> keyword argument to create a mock then attempting to
set a magic method that isn't in the spec will raise an <a href="#id339"><span class="problematic" id="id340">:exc:`AttributeError`</span></a>.</p>
<div class="last system-message" id="id339">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2006); <em><a href="#id340">backlink</a></em></p>
Unknown interpreted text role &quot;exc&quot;.</div>
</div>
<p>The full list of supported magic methods is:</p>
<ul class="simple">
<li><tt class="docutils literal">__hash__</tt>, <tt class="docutils literal">__sizeof__</tt>, <tt class="docutils literal">__repr__</tt> and <tt class="docutils literal">__str__</tt></li>
<li><tt class="docutils literal">__dir__</tt>, <tt class="docutils literal">__format__</tt> and <tt class="docutils literal">__subclasses__</tt></li>
<li><tt class="docutils literal">__round__</tt>, <tt class="docutils literal">__floor__</tt>, <tt class="docutils literal">__trunc__</tt> and <tt class="docutils literal">__ceil__</tt></li>
<li>Comparisons: <tt class="docutils literal">__lt__</tt>, <tt class="docutils literal">__gt__</tt>, <tt class="docutils literal">__le__</tt>, <tt class="docutils literal">__ge__</tt>,
<tt class="docutils literal">__eq__</tt> and <tt class="docutils literal">__ne__</tt></li>
<li>Container methods: <tt class="docutils literal">__getitem__</tt>, <tt class="docutils literal">__setitem__</tt>, <tt class="docutils literal">__delitem__</tt>,
<tt class="docutils literal">__contains__</tt>, <tt class="docutils literal">__len__</tt>, <tt class="docutils literal">__iter__</tt>, <tt class="docutils literal">__reversed__</tt>
and <tt class="docutils literal">__missing__</tt></li>
<li>Context manager: <tt class="docutils literal">__enter__</tt>, <tt class="docutils literal">__exit__</tt>, <tt class="docutils literal">__aenter__</tt> and <tt class="docutils literal">__aexit__</tt></li>
<li>Unary numeric methods: <tt class="docutils literal">__neg__</tt>, <tt class="docutils literal">__pos__</tt> and <tt class="docutils literal">__invert__</tt></li>
<li>The numeric methods (including right hand and in-place variants):
<tt class="docutils literal">__add__</tt>, <tt class="docutils literal">__sub__</tt>, <tt class="docutils literal">__mul__</tt>, <tt class="docutils literal">__matmul__</tt>, <tt class="docutils literal">__div__</tt>, <tt class="docutils literal">__truediv__</tt>,
<tt class="docutils literal">__floordiv__</tt>, <tt class="docutils literal">__mod__</tt>, <tt class="docutils literal">__divmod__</tt>, <tt class="docutils literal">__lshift__</tt>,
<tt class="docutils literal">__rshift__</tt>, <tt class="docutils literal">__and__</tt>, <tt class="docutils literal">__xor__</tt>, <tt class="docutils literal">__or__</tt>, and <tt class="docutils literal">__pow__</tt></li>
<li>Numeric conversion methods: <tt class="docutils literal">__complex__</tt>, <tt class="docutils literal">__int__</tt>, <tt class="docutils literal">__float__</tt>
and <tt class="docutils literal">__index__</tt></li>
<li>Descriptor methods: <tt class="docutils literal">__get__</tt>, <tt class="docutils literal">__set__</tt> and <tt class="docutils literal">__delete__</tt></li>
<li>Pickling: <tt class="docutils literal">__reduce__</tt>, <tt class="docutils literal">__reduce_ex__</tt>, <tt class="docutils literal">__getinitargs__</tt>,
<tt class="docutils literal">__getnewargs__</tt>, <tt class="docutils literal">__getstate__</tt> and <tt class="docutils literal">__setstate__</tt></li>
<li>File system path representation: <tt class="docutils literal">__fspath__</tt></li>
<li>Asynchronous iteration methods: <tt class="docutils literal">__aiter__</tt> and <tt class="docutils literal">__anext__</tt></li>
</ul>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2033)</p>
<p>Unknown directive type &quot;versionchanged&quot;.</p>
<pre class="literal-block">
.. versionchanged:: 3.8
   Added support for :func:`os.PathLike.__fspath__`.

</pre>
</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2036)</p>
<p>Unknown directive type &quot;versionchanged&quot;.</p>
<pre class="literal-block">
.. versionchanged:: 3.8
   Added support for ``__aenter__``, ``__aexit__``, ``__aiter__`` and ``__anext__``.


</pre>
</div>
<p>The following methods exist but are <em>not</em> supported as they are either in use
by mock, can't be set dynamically, or can cause problems:</p>
<ul class="simple">
<li><tt class="docutils literal">__getattr__</tt>, <tt class="docutils literal">__setattr__</tt>, <tt class="docutils literal">__init__</tt> and <tt class="docutils literal">__new__</tt></li>
<li><tt class="docutils literal">__prepare__</tt>, <tt class="docutils literal">__instancecheck__</tt>, <tt class="docutils literal">__subclasscheck__</tt>, <tt class="docutils literal">__del__</tt></li>
</ul>
</div>
<div class="section" id="magic-mock">
<h2>Magic Mock</h2>
<p>There are two <tt class="docutils literal">MagicMock</tt> variants: <a href="#id341"><span class="problematic" id="id342">:class:`MagicMock`</span></a> and <a href="#id343"><span class="problematic" id="id344">:class:`NonCallableMagicMock`</span></a>.</p>
<div class="system-message" id="id341">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2051); <em><a href="#id342">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id343">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2051); <em><a href="#id344">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<p class="magicmock-args kw"><tt class="docutils literal">MagicMock</tt> is a subclass of <a href="#id345"><span class="problematic" id="id346">:class:`Mock`</span></a> with default implementations
of most of the magic methods. You can use <tt class="docutils literal">MagicMock</tt> without having to
configure the magic methods yourself.</p>
<div class="magicmock-args kw system-message" id="id345">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2056); <em><a href="#id346">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<p class="magicmock-args kw">The constructor parameters have the same meaning as for <a href="#id347"><span class="problematic" id="id348">:class:`Mock`</span></a>.</p>
<div class="magicmock-args kw system-message" id="id347">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2060); <em><a href="#id348">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<p class="magicmock-args kw">If you use the <em>spec</em> or <em>spec_set</em> arguments then <em>only</em> magic methods
that exist in the spec will be created.</p>
<p class="noncallablemagicmock-args kw">A non-callable version of <a href="#id349"><span class="problematic" id="id350">:class:`MagicMock`</span></a>.</p>
<div class="noncallablemagicmock-args kw system-message" id="id349">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2068); <em><a href="#id350">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<p class="noncallablemagicmock-args kw">The constructor parameters have the same meaning as for
<a href="#id351"><span class="problematic" id="id352">:class:`MagicMock`</span></a>, with the exception of <em>return_value</em> and
<em>side_effect</em> which have no meaning on a non-callable mock.</p>
<div class="noncallablemagicmock-args kw system-message" id="id351">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2070); <em><a href="#id352">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<p>The magic methods are setup with <a href="#id353"><span class="problematic" id="id354">:class:`MagicMock`</span></a> objects, so you can configure them
and use them in the usual way:</p>
<div class="system-message" id="id353">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2074); <em><a href="#id354">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mock = MagicMock()
&gt;&gt;&gt; mock[3] = 'fish'
&gt;&gt;&gt; mock.__setitem__.assert_called_with(3, 'fish')
&gt;&gt;&gt; mock.__getitem__.return_value = 'result'
&gt;&gt;&gt; mock[2]
'result'
</pre>
</blockquote>
<p>By default many of the protocol methods are required to return objects of a
specific type. These methods are preconfigured with a default return value, so
that they can be used without you having to do anything if you aren't interested
in the return value. You can still <em>set</em> the return value manually if you want
to change the default.</p>
<p>Methods and their defaults:</p>
<ul class="simple">
<li><tt class="docutils literal">__lt__</tt>: <tt class="docutils literal">NotImplemented</tt></li>
<li><tt class="docutils literal">__gt__</tt>: <tt class="docutils literal">NotImplemented</tt></li>
<li><tt class="docutils literal">__le__</tt>: <tt class="docutils literal">NotImplemented</tt></li>
<li><tt class="docutils literal">__ge__</tt>: <tt class="docutils literal">NotImplemented</tt></li>
<li><tt class="docutils literal">__int__</tt>: <tt class="docutils literal">1</tt></li>
<li><tt class="docutils literal">__contains__</tt>: <tt class="docutils literal">False</tt></li>
<li><tt class="docutils literal">__len__</tt>: <tt class="docutils literal">0</tt></li>
<li><tt class="docutils literal">__iter__</tt>: <tt class="docutils literal"><span class="pre">iter([])</span></tt></li>
<li><tt class="docutils literal">__exit__</tt>: <tt class="docutils literal">False</tt></li>
<li><tt class="docutils literal">__aexit__</tt>: <tt class="docutils literal">False</tt></li>
<li><tt class="docutils literal">__complex__</tt>: <tt class="docutils literal">1j</tt></li>
<li><tt class="docutils literal">__float__</tt>: <tt class="docutils literal">1.0</tt></li>
<li><tt class="docutils literal">__bool__</tt>: <tt class="docutils literal">True</tt></li>
<li><tt class="docutils literal">__index__</tt>: <tt class="docutils literal">1</tt></li>
<li><tt class="docutils literal">__hash__</tt>: default hash for the mock</li>
<li><tt class="docutils literal">__str__</tt>: default str for the mock</li>
<li><tt class="docutils literal">__sizeof__</tt>: default sizeof for the mock</li>
</ul>
<p>For example:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mock = MagicMock()
&gt;&gt;&gt; int(mock)
1
&gt;&gt;&gt; len(mock)
0
&gt;&gt;&gt; list(mock)
[]
&gt;&gt;&gt; object() in mock
False
</pre>
</blockquote>
<p>The two equality methods, <a href="#id355"><span class="problematic" id="id356">:meth:`__eq__`</span></a> and <a href="#id357"><span class="problematic" id="id358">:meth:`__ne__`</span></a>, are special.
They do the default equality comparison on identity, using the
<a href="#id359"><span class="problematic" id="id360">:attr:`~Mock.side_effect`</span></a> attribute, unless you change their return value to
return something else:</p>
<div class="system-message" id="id355">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2122); <em><a href="#id356">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id357">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2122); <em><a href="#id358">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id359">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2122); <em><a href="#id360">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; MagicMock() == 3
False
&gt;&gt;&gt; MagicMock() != 3
True
&gt;&gt;&gt; mock = MagicMock()
&gt;&gt;&gt; mock.__eq__.return_value = True
&gt;&gt;&gt; mock == 3
True
</pre>
<p>The return value of <a href="#id361"><span class="problematic" id="id362">:meth:`MagicMock.__iter__`</span></a> can be any iterable object and isn't
required to be an iterator:</p>
<div class="system-message" id="id361">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2136); <em><a href="#id362">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mock = MagicMock()
&gt;&gt;&gt; mock.__iter__.return_value = ['a', 'b', 'c']
&gt;&gt;&gt; list(mock)
['a', 'b', 'c']
&gt;&gt;&gt; list(mock)
['a', 'b', 'c']
</pre>
</blockquote>
<p>If the return value <em>is</em> an iterator, then iterating over it once will consume
it and subsequent iterations will result in an empty list:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mock.__iter__.return_value = iter(['a', 'b', 'c'])
&gt;&gt;&gt; list(mock)
['a', 'b', 'c']
&gt;&gt;&gt; list(mock)
[]
</pre>
</blockquote>
<p><tt class="docutils literal">MagicMock</tt> has all of the supported magic methods configured except for some
of the obscure and obsolete ones. You can still set these up if you want.</p>
<p>Magic methods that are supported but not setup by default in <tt class="docutils literal">MagicMock</tt> are:</p>
<ul class="simple">
<li><tt class="docutils literal">__subclasses__</tt></li>
<li><tt class="docutils literal">__dir__</tt></li>
<li><tt class="docutils literal">__format__</tt></li>
<li><tt class="docutils literal">__get__</tt>, <tt class="docutils literal">__set__</tt> and <tt class="docutils literal">__delete__</tt></li>
<li><tt class="docutils literal">__reversed__</tt> and <tt class="docutils literal">__missing__</tt></li>
<li><tt class="docutils literal">__reduce__</tt>, <tt class="docutils literal">__reduce_ex__</tt>, <tt class="docutils literal">__getinitargs__</tt>, <tt class="docutils literal">__getnewargs__</tt>,
<tt class="docutils literal">__getstate__</tt> and <tt class="docutils literal">__setstate__</tt></li>
<li><tt class="docutils literal">__getformat__</tt> and <tt class="docutils literal">__setformat__</tt></li>
</ul>
<table class="docutils footnote" frame="void" id="id363" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id331">[2]</a></td><td>Magic methods <em>should</em> be looked up on the class rather than the
instance. Different versions of Python are inconsistent about applying this
rule. The supported protocol methods should work with all supported versions
of Python.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id364" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id332">[3]</a></td><td>The function is basically hooked up to the class, but each <tt class="docutils literal">Mock</tt>
instance is kept isolated from the others.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="helpers">
<h1>Helpers</h1>
<div class="section" id="sentinel">
<h2>sentinel</h2>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2185)</p>
<p>Unknown directive type &quot;data&quot;.</p>
<pre class="literal-block">
.. data:: sentinel

   The ``sentinel`` object provides a convenient way of providing unique
   objects for your tests.

   Attributes are created on demand when you access them by name. Accessing
   the same attribute will always return the same object. The objects
   returned have a sensible repr so that test failure messages are readable.

   .. versionchanged:: 3.7
      The ``sentinel`` attributes now preserve their identity when they are
      :mod:`copied &lt;copy&gt;` or :mod:`pickled &lt;pickle&gt;`.

</pre>
</div>
<p>Sometimes when testing you need to test that a specific object is passed as an
argument to another method, or returned. It can be common to create named
sentinel objects to test this. <a href="#id365"><span class="problematic" id="id366">:data:`sentinel`</span></a> provides a convenient way of
creating and testing the identity of objects like this.</p>
<div class="system-message" id="id365">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2198); <em><a href="#id366">backlink</a></em></p>
Unknown interpreted text role &quot;data&quot;.</div>
<p>In this example we monkey patch <tt class="docutils literal">method</tt> to return <tt class="docutils literal">sentinel.some_object</tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; real = ProductionClass()
&gt;&gt;&gt; real.method = Mock(name=&quot;method&quot;)
&gt;&gt;&gt; real.method.return_value = sentinel.some_object
&gt;&gt;&gt; result = real.method()
&gt;&gt;&gt; assert result is sentinel.some_object
&gt;&gt;&gt; sentinel.some_object
sentinel.some_object
</pre>
</blockquote>
</div>
<div class="section" id="default">
<h2>DEFAULT</h2>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2218)</p>
<p>Unknown directive type &quot;data&quot;.</p>
<pre class="literal-block">
.. data:: DEFAULT

    The :data:`DEFAULT` object is a pre-created sentinel (actually
    ``sentinel.DEFAULT``). It can be used by :attr:`~Mock.side_effect`
    functions to indicate that the normal return value should be used.


</pre>
</div>
</div>
<div class="section" id="call">
<h2>call</h2>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2228)</p>
<p>Unknown directive type &quot;function&quot;.</p>
<pre class="literal-block">
.. function:: call(*args, **kwargs)

    :func:`call` is a helper object for making simpler assertions, for comparing with
    :attr:`~Mock.call_args`, :attr:`~Mock.call_args_list`,
    :attr:`~Mock.mock_calls` and :attr:`~Mock.method_calls`. :func:`call` can also be
    used with :meth:`~Mock.assert_has_calls`.

        &gt;&gt;&gt; m = MagicMock(return_value=None)
        &gt;&gt;&gt; m(1, 2, a='foo', b='bar')
        &gt;&gt;&gt; m()
        &gt;&gt;&gt; m.call_args_list == [call(1, 2, a='foo', b='bar'), call()]
        True

</pre>
</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2241)</p>
<p>Unknown directive type &quot;method&quot;.</p>
<pre class="literal-block">
.. method:: call.call_list()

    For a call object that represents multiple calls, :meth:`call_list`
    returns a list of all the intermediate calls as well as the
    final call.

</pre>
</div>
<p><tt class="docutils literal">call_list</tt> is particularly useful for making assertions on &quot;chained calls&quot;. A
chained call is multiple calls on a single line of code. This results in
multiple entries in <a href="#id367"><span class="problematic" id="id368">:attr:`~Mock.mock_calls`</span></a> on a mock. Manually constructing
the sequence of calls can be tedious.</p>
<div class="system-message" id="id367">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2247); <em><a href="#id368">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<p><a href="#id369"><span class="problematic" id="id370">:meth:`~call.call_list`</span></a> can construct the sequence of calls from the same
chained call:</p>
<div class="system-message" id="id369">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2252); <em><a href="#id370">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; m = MagicMock()
&gt;&gt;&gt; m(1).method(arg='foo').other('bar')(2.0)
&lt;MagicMock name='mock().method().other()()' id='...'&gt;
&gt;&gt;&gt; kall = call(1).method(arg='foo').other('bar')(2.0)
&gt;&gt;&gt; kall.call_list()
[call(1),
 call().method(arg='foo'),
 call().method().other('bar'),
 call().method().other()(2.0)]
&gt;&gt;&gt; m.mock_calls == kall.call_list()
True
</pre>
</blockquote>
<p id="calls-as-tuples">A <tt class="docutils literal">call</tt> object is either a tuple of (positional args, keyword args) or
(name, positional args, keyword args) depending on how it was constructed. When
you construct them yourself this isn't particularly interesting, but the <tt class="docutils literal">call</tt>
objects that are in the <a href="#id371"><span class="problematic" id="id372">:attr:`Mock.call_args`</span></a>, <a href="#id373"><span class="problematic" id="id374">:attr:`Mock.call_args_list`</span></a> and
<a href="#id375"><span class="problematic" id="id376">:attr:`Mock.mock_calls`</span></a> attributes can be introspected to get at the individual
arguments they contain.</p>
<div class="system-message" id="id371">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2269); <em><a href="#id372">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id373">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2269); <em><a href="#id374">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id375">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2269); <em><a href="#id376">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<p>The <tt class="docutils literal">call</tt> objects in <a href="#id377"><span class="problematic" id="id378">:attr:`Mock.call_args`</span></a> and <a href="#id379"><span class="problematic" id="id380">:attr:`Mock.call_args_list`</span></a>
are two-tuples of (positional args, keyword args) whereas the <tt class="docutils literal">call</tt> objects
in <a href="#id381"><span class="problematic" id="id382">:attr:`Mock.mock_calls`</span></a>, along with ones you construct yourself, are
three-tuples of (name, positional args, keyword args).</p>
<div class="system-message" id="id377">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2276); <em><a href="#id378">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id379">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2276); <em><a href="#id380">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id381">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2276); <em><a href="#id382">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<p>You can use their &quot;tupleness&quot; to pull out the individual arguments for more
complex introspection and assertions. The positional arguments are a tuple
(an empty tuple if there are no positional arguments) and the keyword
arguments are a dictionary:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; m = MagicMock(return_value=None)
&gt;&gt;&gt; m(1, 2, 3, arg='one', arg2='two')
&gt;&gt;&gt; kall = m.call_args
&gt;&gt;&gt; kall.args
(1, 2, 3)
&gt;&gt;&gt; kall.kwargs
{'arg': 'one', 'arg2': 'two'}
&gt;&gt;&gt; kall.args is kall[0]
True
&gt;&gt;&gt; kall.kwargs is kall[1]
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; m = MagicMock()
&gt;&gt;&gt; m.foo(4, 5, 6, arg='two', arg2='three')
&lt;MagicMock name='mock.foo()' id='...'&gt;
&gt;&gt;&gt; kall = m.mock_calls[0]
&gt;&gt;&gt; name, args, kwargs = kall
&gt;&gt;&gt; name
'foo'
&gt;&gt;&gt; args
(4, 5, 6)
&gt;&gt;&gt; kwargs
{'arg': 'two', 'arg2': 'three'}
&gt;&gt;&gt; name is m.mock_calls[0][0]
True
</pre>
</blockquote>
</div>
<div class="section" id="create-autospec">
<h2>create_autospec</h2>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2316)</p>
<p>Unknown directive type &quot;function&quot;.</p>
<pre class="literal-block">
.. function:: create_autospec(spec, spec_set=False, instance=False, **kwargs)

    Create a mock object using another object as a spec. Attributes on the
    mock will use the corresponding attribute on the *spec* object as their
    spec.

    Functions or methods being mocked will have their arguments checked to
    ensure that they are called with the correct signature.

    If *spec_set* is ``True`` then attempting to set attributes that don't exist
    on the spec object will raise an :exc:`AttributeError`.

    If a class is used as a spec then the return value of the mock (the
    instance of the class) will have the same spec. You can use a class as the
    spec for an instance object by passing ``instance=True``. The returned mock
    will only be callable if instances of the mock are callable.

    :func:`create_autospec` also takes arbitrary keyword arguments that are passed to
    the constructor of the created mock.

</pre>
</div>
<p>See <a href="#id383"><span class="problematic" id="id384">:ref:`auto-speccing`</span></a> for examples of how to use auto-speccing with
<a href="#id385"><span class="problematic" id="id386">:func:`create_autospec`</span></a> and the <em>autospec</em> argument to <a href="#id387"><span class="problematic" id="id388">:func:`patch`</span></a>.</p>
<div class="system-message" id="id383">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2336); <em><a href="#id384">backlink</a></em></p>
Unknown interpreted text role &quot;ref&quot;.</div>
<div class="system-message" id="id385">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2336); <em><a href="#id386">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id387">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2336); <em><a href="#id388">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2340)</p>
<p>Unknown directive type &quot;versionchanged&quot;.</p>
<pre class="literal-block">
.. versionchanged:: 3.8

    :func:`create_autospec` now returns an :class:`AsyncMock` if the target is
    an async function.


</pre>
</div>
</div>
<div class="section" id="any">
<h2>ANY</h2>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2349)</p>
<p>Unknown directive type &quot;data&quot;.</p>
<pre class="literal-block">
.. data:: ANY

</pre>
</div>
<p>Sometimes you may need to make assertions about <em>some</em> of the arguments in a
call to mock, but either not care about some of the arguments or want to pull
them individually out of <a href="#id389"><span class="problematic" id="id390">:attr:`~Mock.call_args`</span></a> and make more complex
assertions on them.</p>
<div class="system-message" id="id389">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2351); <em><a href="#id390">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<p>To ignore certain arguments you can pass in objects that compare equal to
<em>everything</em>. Calls to <a href="#id391"><span class="problematic" id="id392">:meth:`~Mock.assert_called_with`</span></a> and
<a href="#id393"><span class="problematic" id="id394">:meth:`~Mock.assert_called_once_with`</span></a> will then succeed no matter what was
passed in.</p>
<div class="system-message" id="id391">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2356); <em><a href="#id392">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id393">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2356); <em><a href="#id394">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mock = Mock(return_value=None)
&gt;&gt;&gt; mock('foo', bar=object())
&gt;&gt;&gt; mock.assert_called_once_with('foo', bar=ANY)
</pre>
</blockquote>
<p><a href="#id395"><span class="problematic" id="id396">:data:`ANY`</span></a> can also be used in comparisons with call lists like
<a href="#id397"><span class="problematic" id="id398">:attr:`~Mock.mock_calls`</span></a>:</p>
<div class="system-message" id="id395">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2365); <em><a href="#id396">backlink</a></em></p>
Unknown interpreted text role &quot;data&quot;.</div>
<div class="system-message" id="id397">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2365); <em><a href="#id398">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; m = MagicMock(return_value=None)
&gt;&gt;&gt; m(1)
&gt;&gt;&gt; m(1, 2)
&gt;&gt;&gt; m(object())
&gt;&gt;&gt; m.mock_calls == [call(1), call(1, 2), ANY]
True
</pre>
</blockquote>
</div>
<div class="section" id="filter-dir">
<h2>FILTER_DIR</h2>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2380)</p>
<p>Unknown directive type &quot;data&quot;.</p>
<pre class="literal-block">
.. data:: FILTER_DIR

</pre>
</div>
<p><a href="#id399"><span class="problematic" id="id400">:data:`FILTER_DIR`</span></a> is a module level variable that controls the way mock objects
respond to <a href="#id401"><span class="problematic" id="id402">:func:`dir`</span></a> (only for Python 2.6 or more recent). The default is <tt class="docutils literal">True</tt>,
which uses the filtering described below, to only show useful members. If you
dislike this filtering, or need to switch it off for diagnostic purposes, then
set <tt class="docutils literal">mock.FILTER_DIR = False</tt>.</p>
<div class="system-message" id="id399">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2382); <em><a href="#id400">backlink</a></em></p>
Unknown interpreted text role &quot;data&quot;.</div>
<div class="system-message" id="id401">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2382); <em><a href="#id402">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<p>With filtering on, <tt class="docutils literal">dir(some_mock)</tt> shows only useful attributes and will
include any dynamically created attributes that wouldn't normally be shown.
If the mock was created with a <em>spec</em> (or <em>autospec</em> of course) then all the
attributes from the original are shown, even if they haven't been accessed
yet:</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2394)</p>
<p>Unknown directive type &quot;doctest&quot;.</p>
<pre class="literal-block">
.. doctest::
    :options: +ELLIPSIS,+NORMALIZE_WHITESPACE

    &gt;&gt;&gt; dir(Mock())
    ['assert_any_call',
     'assert_called',
     'assert_called_once',
     'assert_called_once_with',
     'assert_called_with',
     'assert_has_calls',
     'assert_not_called',
     'attach_mock',
     ...
    &gt;&gt;&gt; from urllib import request
    &gt;&gt;&gt; dir(Mock(spec=request))
    ['AbstractBasicAuthHandler',
     'AbstractDigestAuthHandler',
     'AbstractHTTPHandler',
     'BaseHandler',
     ...

</pre>
</div>
<p>Many of the not-very-useful (private to <a href="#id403"><span class="problematic" id="id404">:class:`Mock`</span></a> rather than the thing being
mocked) underscore and double underscore prefixed attributes have been
filtered from the result of calling <a href="#id405"><span class="problematic" id="id406">:func:`dir`</span></a> on a <a href="#id407"><span class="problematic" id="id408">:class:`Mock`</span></a>. If you dislike this
behaviour you can switch it off by setting the module level switch
<a href="#id409"><span class="problematic" id="id410">:data:`FILTER_DIR`</span></a>:</p>
<div class="system-message" id="id403">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2415); <em><a href="#id404">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id405">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2415); <em><a href="#id406">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id407">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2415); <em><a href="#id408">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id409">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2415); <em><a href="#id410">backlink</a></em></p>
Unknown interpreted text role &quot;data&quot;.</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2421)</p>
<p>Unknown directive type &quot;doctest&quot;.</p>
<pre class="literal-block">
.. doctest::
    :options: +ELLIPSIS,+NORMALIZE_WHITESPACE

    &gt;&gt;&gt; from unittest import mock
    &gt;&gt;&gt; mock.FILTER_DIR = False
    &gt;&gt;&gt; dir(mock.Mock())
    ['_NonCallableMock__get_return_value',
     '_NonCallableMock__get_side_effect',
     '_NonCallableMock__return_value_doc',
     '_NonCallableMock__set_return_value',
     '_NonCallableMock__set_side_effect',
     '__call__',
     '__class__',
     ...

</pre>
</div>
<p>Alternatively you can just use <tt class="docutils literal">vars(my_mock)</tt> (instance members) and
<tt class="docutils literal">dir(type(my_mock))</tt> (type members) to bypass the filtering irrespective of
<a href="#id411"><span class="problematic" id="id412">:data:`mock.FILTER_DIR`</span></a>.</p>
<div class="system-message" id="id411">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2436); <em><a href="#id412">backlink</a></em></p>
Unknown interpreted text role &quot;data&quot;.</div>
</div>
<div class="section" id="mock-open">
<h2>mock_open</h2>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2444)</p>
<p>Unknown directive type &quot;function&quot;.</p>
<pre class="literal-block">
.. function:: mock_open(mock=None, read_data=None)

   A helper function to create a mock to replace the use of :func:`open`. It works
   for :func:`open` called directly or used as a context manager.

   The *mock* argument is the mock object to configure. If ``None`` (the
   default) then a :class:`MagicMock` will be created for you, with the API limited
   to methods or attributes available on standard file handles.

   *read_data* is a string for the :meth:`~io.IOBase.read`,
   :meth:`~io.IOBase.readline`, and :meth:`~io.IOBase.readlines` methods
   of the file handle to return.  Calls to those methods will take data from
   *read_data* until it is depleted.  The mock of these methods is pretty
   simplistic: every time the *mock* is called, the *read_data* is rewound to
   the start.  If you need more control over the data that you are feeding to
   the tested code you will need to customize this mock for yourself.  When that
   is insufficient, one of the in-memory filesystem packages on `PyPI
   &lt;https://pypi.org&gt;`_ can offer a realistic filesystem for testing.

   .. versionchanged:: 3.4
      Added :meth:`~io.IOBase.readline` and :meth:`~io.IOBase.readlines` support.
      The mock of :meth:`~io.IOBase.read` changed to consume *read_data* rather
      than returning it on each call.

   .. versionchanged:: 3.5
      *read_data* is now reset on each call to the *mock*.

   .. versionchanged:: 3.8
      Added :meth:`__iter__` to implementation so that iteration (such as in for
      loops) correctly consumes *read_data*.

</pre>
</div>
<p>Using <a href="#id413"><span class="problematic" id="id414">:func:`open`</span></a> as a context manager is a great way to ensure your file handles
are closed properly and is becoming common:</p>
<div class="system-message" id="id413">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2475); <em><a href="#id414">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<pre class="literal-block">
with open('/some/path', 'w') as f:
    f.write('something')
</pre>
<p>The issue is that even if you mock out the call to <a href="#id415"><span class="problematic" id="id416">:func:`open`</span></a> it is the
<em>returned object</em> that is used as a context manager (and has <a href="#id417"><span class="problematic" id="id418">:meth:`__enter__`</span></a> and
<a href="#id419"><span class="problematic" id="id420">:meth:`__exit__`</span></a> called).</p>
<div class="system-message" id="id415">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2481); <em><a href="#id416">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id417">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2481); <em><a href="#id418">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id419">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2481); <em><a href="#id420">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<p>Mocking context managers with a <a href="#id421"><span class="problematic" id="id422">:class:`MagicMock`</span></a> is common enough and fiddly
enough that a helper function is useful.</p>
<div class="system-message" id="id421">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2485); <em><a href="#id422">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; m = mock_open()
&gt;&gt;&gt; with patch('__main__.open', m):
...     with open('foo', 'w') as h:
...         h.write('some stuff')
...
&gt;&gt;&gt; m.mock_calls
[call('foo', 'w'),
 call().__enter__(),
 call().write('some stuff'),
 call().__exit__(None, None, None)]
&gt;&gt;&gt; m.assert_called_once_with('foo', 'w')
&gt;&gt;&gt; handle = m()
&gt;&gt;&gt; handle.write.assert_called_once_with('some stuff')
</pre>
<p>And for reading files:</p>
<pre class="literal-block">
&gt;&gt;&gt; with patch('__main__.open', mock_open(read_data='bibble')) as m:
...     with open('foo') as h:
...         result = h.read()
...
&gt;&gt;&gt; m.assert_called_once_with('foo')
&gt;&gt;&gt; assert result == 'bibble'
</pre>
</div>
<div class="section" id="autospeccing">
<span id="auto-speccing"></span><h2>Autospeccing</h2>
<p>Autospeccing is based on the existing <a href="#id423"><span class="problematic" id="id424">:attr:`spec`</span></a> feature of mock. It limits the
api of mocks to the api of an original object (the spec), but it is recursive
(implemented lazily) so that attributes of mocks only have the same api as
the attributes of the spec. In addition mocked functions / methods have the
same call signature as the original so they raise a <a href="#id425"><span class="problematic" id="id426">:exc:`TypeError`</span></a> if they are
called incorrectly.</p>
<div class="system-message" id="id423">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2517); <em><a href="#id424">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<div class="system-message" id="id425">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2517); <em><a href="#id426">backlink</a></em></p>
Unknown interpreted text role &quot;exc&quot;.</div>
<p>Before I explain how auto-speccing works, here's why it is needed.</p>
<p><a href="#id427"><span class="problematic" id="id428">:class:`Mock`</span></a> is a very powerful and flexible object, but it suffers from two flaws
when used to mock out objects from a system under test. One of these flaws is
specific to the <a href="#id429"><span class="problematic" id="id430">:class:`Mock`</span></a> api and the other is a more general problem with using
mock objects.</p>
<div class="system-message" id="id427">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2526); <em><a href="#id428">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id429">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2526); <em><a href="#id430">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<p>First the problem specific to <a href="#id431"><span class="problematic" id="id432">:class:`Mock`</span></a>. <a href="#id433"><span class="problematic" id="id434">:class:`Mock`</span></a> has two assert methods that are
extremely handy: <a href="#id435"><span class="problematic" id="id436">:meth:`~Mock.assert_called_with`</span></a> and
<a href="#id437"><span class="problematic" id="id438">:meth:`~Mock.assert_called_once_with`</span></a>.</p>
<div class="system-message" id="id431">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2531); <em><a href="#id432">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id433">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2531); <em><a href="#id434">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id435">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2531); <em><a href="#id436">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id437">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2531); <em><a href="#id438">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; mock = Mock(name='Thing', return_value=None)
&gt;&gt;&gt; mock(1, 2, 3)
&gt;&gt;&gt; mock.assert_called_once_with(1, 2, 3)
&gt;&gt;&gt; mock(1, 2, 3)
&gt;&gt;&gt; mock.assert_called_once_with(1, 2, 3)
Traceback (most recent call last):
 ...
AssertionError: Expected 'mock' to be called once. Called 2 times.
</pre>
</blockquote>
<p>Because mocks auto-create attributes on demand, and allow you to call them
with arbitrary arguments, if you misspell one of these assert methods then
your assertion is gone:</p>
<pre class="code pycon literal-block">
<span class="generic prompt">&gt;&gt;&gt; </span><span class="name">mock</span> <span class="operator">=</span> <span class="name">Mock</span><span class="punctuation">(</span><span class="name">name</span><span class="operator">=</span><span class="literal string single">'Thing'</span><span class="punctuation">,</span> <span class="name">return_value</span><span class="operator">=</span><span class="keyword constant">None</span><span class="punctuation">)</span>
<span class="generic prompt">&gt;&gt;&gt; </span><span class="name">mock</span><span class="punctuation">(</span><span class="literal number integer">1</span><span class="punctuation">,</span> <span class="literal number integer">2</span><span class="punctuation">,</span> <span class="literal number integer">3</span><span class="punctuation">)</span>
<span class="generic prompt">&gt;&gt;&gt; </span><span class="name">mock</span><span class="operator">.</span><span class="name">assret_called_once_with</span><span class="punctuation">(</span><span class="literal number integer">4</span><span class="punctuation">,</span> <span class="literal number integer">5</span><span class="punctuation">,</span> <span class="literal number integer">6</span><span class="punctuation">)</span>
</pre>
<p>Your tests can pass silently and incorrectly because of the typo.</p>
<p>The second issue is more general to mocking. If you refactor some of your
code, rename members and so on, any tests for code that is still using the
<em>old api</em> but uses mocks instead of the real objects will still pass. This
means your tests can all pass even though your code is broken.</p>
<p>Note that this is another reason why you need integration tests as well as
unit tests. Testing everything in isolation is all fine and dandy, but if you
don't test how your units are &quot;wired together&quot; there is still lots of room
for bugs that tests might have caught.</p>
<p><a href="#id439"><span class="problematic" id="id440">:mod:`mock`</span></a> already provides a feature to help with this, called speccing. If you
use a class or instance as the <a href="#id441"><span class="problematic" id="id442">:attr:`spec`</span></a> for a mock then you can only access
attributes on the mock that exist on the real class:</p>
<div class="system-message" id="id439">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2566); <em><a href="#id440">backlink</a></em></p>
Unknown interpreted text role &quot;mod&quot;.</div>
<div class="system-message" id="id441">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2566); <em><a href="#id442">backlink</a></em></p>
Unknown interpreted text role &quot;attr&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from urllib import request
&gt;&gt;&gt; mock = Mock(spec=request.Request)
&gt;&gt;&gt; mock.assret_called_with
Traceback (most recent call last):
 ...
AttributeError: Mock object has no attribute 'assret_called_with'
</pre>
</blockquote>
<p>The spec only applies to the mock itself, so we still have the same issue
with any methods on the mock:</p>
<pre class="code pycon literal-block">
<span class="generic prompt">&gt;&gt;&gt; </span><span class="name">mock</span><span class="operator">.</span><span class="name">has_data</span><span class="punctuation">()</span>
<span class="generic output">&lt;mock.Mock object at 0x...&gt;
</span><span class="generic prompt">&gt;&gt;&gt; </span><span class="name">mock</span><span class="operator">.</span><span class="name">has_data</span><span class="operator">.</span><span class="name">assret_called_with</span><span class="punctuation">()</span>
</pre>
<p>Auto-speccing solves this problem. You can either pass <tt class="docutils literal">autospec=True</tt> to
<a href="#id443"><span class="problematic" id="id444">:func:`patch`</span></a> / <a href="#id445"><span class="problematic" id="id446">:func:`patch.object`</span></a> or use the <a href="#id447"><span class="problematic" id="id448">:func:`create_autospec`</span></a> function to create a
mock with a spec. If you use the <tt class="docutils literal">autospec=True</tt> argument to <a href="#id449"><span class="problematic" id="id450">:func:`patch`</span></a> then the
object that is being replaced will be used as the spec object. Because the
speccing is done &quot;lazily&quot; (the spec is created as attributes on the mock are
accessed) you can use it with very complex or deeply nested objects (like
modules that import modules that import modules) without a big performance
hit.</p>
<div class="system-message" id="id443">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2586); <em><a href="#id444">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id445">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2586); <em><a href="#id446">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id447">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2586); <em><a href="#id448">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id449">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2586); <em><a href="#id450">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<p>Here's an example of it in use:</p>
<pre class="literal-block">
&gt;&gt;&gt; from urllib import request
&gt;&gt;&gt; patcher = patch('__main__.request', autospec=True)
&gt;&gt;&gt; mock_request = patcher.start()
&gt;&gt;&gt; request is mock_request
True
&gt;&gt;&gt; mock_request.Request
&lt;MagicMock name='request.Request' spec='Request' id='...'&gt;
</pre>
<p>You can see that <a href="#id451"><span class="problematic" id="id452">:class:`request.Request`</span></a> has a spec. <a href="#id453"><span class="problematic" id="id454">:class:`request.Request`</span></a> takes two
arguments in the constructor (one of which is <em>self</em>). Here's what happens if
we try to call it incorrectly:</p>
<div class="system-message" id="id451">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2605); <em><a href="#id452">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id453">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2605); <em><a href="#id454">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; req = request.Request()
Traceback (most recent call last):
 ...
TypeError: &lt;lambda&gt;() takes at least 2 arguments (1 given)
</pre>
<p>The spec also applies to instantiated classes (i.e. the return value of
specced mocks):</p>
<pre class="literal-block">
&gt;&gt;&gt; req = request.Request('foo')
&gt;&gt;&gt; req
&lt;NonCallableMagicMock name='request.Request()' spec='Request' id='...'&gt;
</pre>
<p><a href="#id455"><span class="problematic" id="id456">:class:`Request`</span></a> objects are not callable, so the return value of instantiating our
mocked out <a href="#id457"><span class="problematic" id="id458">:class:`request.Request`</span></a> is a non-callable mock. With the spec in place
any typos in our asserts will raise the correct error:</p>
<div class="system-message" id="id455">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2621); <em><a href="#id456">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<div class="system-message" id="id457">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2621); <em><a href="#id458">backlink</a></em></p>
Unknown interpreted text role &quot;class&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; req.add_header('spam', 'eggs')
&lt;MagicMock name='request.Request().add_header()' id='...'&gt;
&gt;&gt;&gt; req.add_header.assret_called_with
Traceback (most recent call last):
 ...
AttributeError: Mock object has no attribute 'assret_called_with'
&gt;&gt;&gt; req.add_header.assert_called_with('spam', 'eggs')
</pre>
<p>In many cases you will just be able to add <tt class="docutils literal">autospec=True</tt> to your existing
<a href="#id459"><span class="problematic" id="id460">:func:`patch`</span></a> calls and then be protected against bugs due to typos and api
changes.</p>
<div class="system-message" id="id459">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2633); <em><a href="#id460">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<p>As well as using <em>autospec</em> through <a href="#id461"><span class="problematic" id="id462">:func:`patch`</span></a> there is a
<a href="#id463"><span class="problematic" id="id464">:func:`create_autospec`</span></a> for creating autospecced mocks directly:</p>
<div class="system-message" id="id461">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2637); <em><a href="#id462">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<div class="system-message" id="id463">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2637); <em><a href="#id464">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from urllib import request
&gt;&gt;&gt; mock_request = create_autospec(request)
&gt;&gt;&gt; mock_request.Request('foo', 'bar')
&lt;NonCallableMagicMock name='mock.Request()' spec='Request' id='...'&gt;
</pre>
</blockquote>
<p>This isn't without caveats and limitations however, which is why it is not
the default behaviour. In order to know what attributes are available on the
spec object, autospec has to introspect (access attributes) the spec. As you
traverse attributes on the mock a corresponding traversal of the original
object is happening under the hood. If any of your specced objects have
properties or descriptors that can trigger code execution then you may not be
able to use autospec. On the other hand it is much better to design your
objects so that introspection is safe <a class="footnote-reference" href="#id474" id="id465">[4]</a>.</p>
<p>A more serious problem is that it is common for instance attributes to be
created in the <a href="#id466"><span class="problematic" id="id467">:meth:`__init__`</span></a> method and not to exist on the class at all.
<em>autospec</em> can't know about any dynamically created attributes and restricts
the api to visible attributes.</p>
<div class="system-message" id="id466">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2654); <em><a href="#id467">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; class Something:
...   def __init__(self):
...     self.a = 33
...
&gt;&gt;&gt; with patch('__main__.Something', autospec=True):
...   thing = Something()
...   thing.a
...
Traceback (most recent call last):
  ...
AttributeError: Mock object has no attribute 'a'
</pre>
<p>There are a few different ways of resolving this problem. The easiest, but
not necessarily the least annoying, way is to simply set the required
attributes on the mock after creation. Just because <em>autospec</em> doesn't allow
you to fetch attributes that don't exist on the spec it doesn't prevent you
setting them:</p>
<pre class="literal-block">
&gt;&gt;&gt; with patch('__main__.Something', autospec=True):
...   thing = Something()
...   thing.a = 33
...
</pre>
<p>There is a more aggressive version of both <em>spec</em> and <em>autospec</em> that <em>does</em>
prevent you setting non-existent attributes. This is useful if you want to
ensure your code only <em>sets</em> valid attributes too, but obviously it prevents
this particular scenario:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; with patch('__main__.Something', autospec=True, spec_set=True):
...   thing = Something()
...   thing.a = 33
...
Traceback (most recent call last):
 ...
AttributeError: Mock object has no attribute 'a'
</pre>
</blockquote>
<p>Probably the best way of solving the problem is to add class attributes as
default values for instance members initialised in <a href="#id468"><span class="problematic" id="id469">:meth:`__init__`</span></a>. Note that if
you are only setting default attributes in <a href="#id470"><span class="problematic" id="id471">:meth:`__init__`</span></a> then providing them via
class attributes (shared between instances of course) is faster too. e.g.</p>
<div class="system-message" id="id468">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2695); <em><a href="#id469">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<div class="system-message" id="id470">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2695); <em><a href="#id471">backlink</a></em></p>
Unknown interpreted text role &quot;meth&quot;.</div>
<pre class="code python literal-block">
<span class="keyword">class</span> <span class="name class">Something</span><span class="punctuation">:</span>
    <span class="name">a</span> <span class="operator">=</span> <span class="literal number integer">33</span>
</pre>
<p>This brings up another issue. It is relatively common to provide a default
value of <tt class="docutils literal">None</tt> for members that will later be an object of a different type.
<tt class="docutils literal">None</tt> would be useless as a spec because it wouldn't let you access <em>any</em>
attributes or methods on it. As <tt class="docutils literal">None</tt> is <em>never</em> going to be useful as a
spec, and probably indicates a member that will normally of some other type,
autospec doesn't use a spec for members that are set to <tt class="docutils literal">None</tt>. These will
just be ordinary mocks (well - MagicMocks):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class Something:
...     member = None
...
&gt;&gt;&gt; mock = create_autospec(Something)
&gt;&gt;&gt; mock.member.foo.bar.baz()
&lt;MagicMock name='mock.member.foo.bar.baz()' id='...'&gt;
</pre>
</blockquote>
<p>If modifying your production classes to add defaults isn't to your liking
then there are more options. One of these is simply to use an instance as the
spec rather than the class. The other is to create a subclass of the
production class and add the defaults to the subclass without affecting the
production class. Both of these require you to use an alternative object as
the spec. Thankfully <a href="#id472"><span class="problematic" id="id473">:func:`patch`</span></a> supports this - you can simply pass the
alternative object as the <em>autospec</em> argument:</p>
<div class="system-message" id="id472">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2720); <em><a href="#id473">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
<pre class="literal-block">
&gt;&gt;&gt; class Something:
...   def __init__(self):
...     self.a = 33
...
&gt;&gt;&gt; class SomethingForTest(Something):
...   a = 33
...
&gt;&gt;&gt; p = patch('__main__.Something', autospec=SomethingForTest)
&gt;&gt;&gt; mock = p.start()
&gt;&gt;&gt; mock.a
&lt;NonCallableMagicMock name='Something.a' spec='int' id='...'&gt;
</pre>
<table class="docutils footnote" frame="void" id="id474" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id465">[4]</a></td><td><p class="first">This only applies to classes or already instantiated objects. Calling
a mocked class to create a mock instance <em>does not</em> create a real instance.
It is only attribute lookups - along with calls to <a href="#id475"><span class="problematic" id="id476">:func:`dir`</span></a> - that are done.</p>
<div class="last system-message" id="id475">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2741); <em><a href="#id476">backlink</a></em></p>
Unknown interpreted text role &quot;func&quot;.</div>
</td></tr>
</tbody>
</table>
</div>
<div class="section" id="sealing-mocks">
<h2>Sealing mocks</h2>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2749)</p>
<p>Unknown directive type &quot;testsetup&quot;.</p>
<pre class="literal-block">
.. testsetup::

    from unittest.mock import seal

</pre>
</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">unittest.mock.rst</tt>, line 2753)</p>
<p>Unknown directive type &quot;function&quot;.</p>
<pre class="literal-block">
.. function:: seal(mock)

    Seal will disable the automatic creation of mocks when accessing an attribute of
    the mock being sealed or any of its attributes that are already mocks recursively.

    If a mock instance with a name or a spec is assigned to an attribute
    it won't be considered in the sealing chain. This allows one to prevent seal from
    fixing part of the mock object. ::

        &gt;&gt;&gt; mock = Mock()
        &gt;&gt;&gt; mock.submock.attribute1 = 2
        &gt;&gt;&gt; mock.not_submock = mock.Mock(name=&quot;sample_name&quot;)
        &gt;&gt;&gt; seal(mock)
        &gt;&gt;&gt; mock.new_attribute  # This will raise AttributeError.
        &gt;&gt;&gt; mock.submock.attribute2  # This will raise AttributeError.
        &gt;&gt;&gt; mock.not_submock.attribute2  # This won't raise.

    .. versionadded:: 3.7
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
